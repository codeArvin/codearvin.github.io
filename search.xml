<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[培训自学计划]]></title>
      <url>/2018/02/02/%E5%9F%B9%E8%AE%AD%E8%87%AA%E5%AD%A6%E8%AE%A1%E5%88%92/</url>
      <content type="html"><![CDATA[<h1 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h1><h2 id="1-什么是HTML-amp-HTML发展历程"><a href="#1-什么是HTML-amp-HTML发展历程" class="headerlink" title="1. 什么是HTML &amp; HTML发展历程"></a>1. 什么是HTML &amp; HTML发展历程</h2><p><a href="https://www.qingsword.com/qing/html5-1.html" target="_blank" rel="external">参考</a></p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML（Hypertext Markup Language）中文名称为”超文本标记语言”，它遵循”万维网联盟（W3C）”定义的结构规范，在HTML5之前的版本中，W3C将HTML定义为”标准通用标记语言（SGML，Standard Generalized Markup Language）”的一种应用；而SGML是一种定义标记语言的技术，它通过”文档类型定义（DTD，Document Type Definition）”的形式来指定允许的文档结构，浏览器按照SGML中定义的”DTD规范”来呈现HTML文档的内容。</p>
<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><p>HTML标准版本有：Html2.0、HTML3.2、HTML4.0、HTML4.01、HTML5（它并不是基于SGML或XML定义的，而是类似英文散文规范的形式）。</p>
<p>HTML1并不曾存在，也没有人知道它为什么不存在，也许存在过，在实验室里；HTML的第一个官方版本是由IETF（互联网工程任务组）推出的HTML2.0，后来W3C取代IETF的角色，成为HTML的标准组织，1990年代的后半页，HTML的版本被频繁修改，直到1999年HTML4.01的出现，至此，HTML到达了它诞生以来第一个命运的转折点；</p>
<p>W3C在HTML4.01之后发布的第一个修订版本是XHTML1.0，其中X代表”eXtensible”（扩展），当然也有人将之解读为 “eXtreme”（极端）；XHTML1.0是基于HTML4.01的，并没有引入任何新标签或属性，唯一的区别是，HTML语法比较随便，而XHTML则要求XML般的严格语法，这种严格的标准已经惹怒了当时的一部分开发者；XHTML1.0的推出刚好碰上了CSS的崛起，如果说XHTML1.0是XML风格的HTML，那么后来的修订版XHTML1.1则是货真价实的XML；</p>
<p>紧随其后W3C发布了第二个修订版XHTML2，它不向前兼容，甚至不兼容之前的HTML；W3C将它定义成一种全新的语言，对于HTML开发者来说这是一场灾难，忍无可忍的开发者们决定放弃W3C制定的标准，他们投奔了另外一个组织WHATWG，而WHATWG研发了一种新的HTML标准，他们将它命名为HTML 5；</p>
<p>在WHATWG致力于HTML5的同时，W3C继续着他们的XHTML2.0；然而，他们却慢慢的陷入了困境，几个月后，W3C组建了一个新的HTML工作组，他们非常明智的选择了WHATWG的成果作为基础；这一转变带来了一些困惑，W3C同时进行着两套规范，XHTML2和HTML 5（注意，W3C的HTTML 5在5之前有个空格，而WHATWG的HTML5则没有空格），而与此同时WHATWG也在进行着同样的工作；</p>
<p>这一混乱局面到了2009年才开始变得清晰，W3C宣布终止XHTML2的工作，这是一份关于XHTML2迟到的讣告，也正式宣布了HTML5走上历史的舞台，成为当今最主流的HTML标准规范。</p>
<h2 id="2-XHTML发展历程"><a href="#2-XHTML发展历程" class="headerlink" title="2. XHTML发展历程"></a>2. XHTML发展历程</h2><h3 id="XHTML"><a href="#XHTML" class="headerlink" title="XHTML"></a>XHTML</h3><p>可扩展超文本标记语言（英语：eXtensible HyperText Markup Language，XHTML），是一种标记语言，表现方式与超文本标记语言（HTML）类似，不过语法上更加严格。从继承关系上讲，HTML是一种基于标准通用标记语言（SGML）的应用，是一种非常灵活的置标语言，而XHTML则基于可扩展标记语言（XML），XML是SGML的一个子集。XHTML 1.0在2000年1月26日成为W3C的推荐标准。</p>
<p>XHTML1.1为XHTML最后的独立标准，2.0止于草案阶段。XHTML5则是属于HTML5标准的一部分，且名称已改为“以XML序列化的HTML5”，而非“可扩展的HTML”。在今日(2017年)，XHTML5比起HTML5仍远远并非主流。</p>
<h3 id="发展-1"><a href="#发展-1" class="headerlink" title="发展"></a>发展</h3><p>XHTML是“3种HTML 4文件根据XML 1.0标准重组”而成的[1]。而W3C亦继续建议使用HTML 4.01和积极地研究HTML5及XHTML的计划。于2002年8月发表的XHTML 1.0的建议中，W3C指出XHTML家族将会是Internet的新阶段。而转换使用XHTML可以令开发人员接触XML和其好处，并可以确保以XHTML开发的网页于未来的兼容性。</p>
<p>HTML语法要求比较松散，这样对网页编写者来说，比较方便，但对于机器来说，语言的语法越松散，处理起来就越困难，对于传统的电脑来说，还有能力兼容松散语法，但对于许多其他设备，比如手机，难度就比较大。因此产生了由DTD定义规则，语法要求更加严格的XHTML。</p>
<p>大部分常见的浏览器都可以正确地解析XHTML，即使老一点的浏览器，XHTML作为HTML的一个子集，许多也可以解析。也就是说，几乎所有的网页浏览器在正确解析HTML的同时，可兼容XHTML。当然，从HTML完全转移到XHTML，还需要一些过程。</p>
<p>跟CSS（Cascading Style Sheets，层叠式样式表）结合后，XHTML能发挥真正的威力；这使实现样式跟内容的分离的同时，又能有机地组合网页代码，在另外的单独文件中，还可以混合各种XML应用，比如MathML、SVG。</p>
<p>从HTML到XHTML过渡的变化比较小，主要是为了适应XML。最大的变化在于文档必须是良构的，所有标签必须闭合，也就是说开始标签要有相应的结束标签。另外，XHTML中所有的标签必须小写。而按照HTML 2.0以来的传统，很多人都是将标签大写，这点两者的差异显著。在XHTML中，所有的参数值，包括数字，必须用双引号括起来（而在SGML和HTML中，引号不是必须的，当内容只是数字、字母及其它允许的特殊字符时，可以不用引号）。所有元素，包括空元素，比如img、br等，也都必须闭合，实现的方式是在开始标签末尾加入斜扛，比如<code>&lt;img ... /&gt;</code> 、<code>&lt;br /&gt;</code>。省略参数，比如<code>&lt;option selected&gt;</code>，也不允许，必须用<code>&lt;option selected=&quot;selected&quot;&gt;</code>。两者的详细差别，可通过W3C XHTML说明来查阅。</p>
<p>至现时为止，XHTML共有以下几个版本：</p>
<p>XHTML 1.0 Strict（严格版）是参照“HTML 4.01 Strict”改编，但不包括被弃用的元素。其文件类型描述为：<br><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</code></p>
<p>XHTML 1.0 Transitional（过渡版）是参照“HTML 4.01 Transitional”改编，包括已于Strict版本被弃用的呈现性元素（例如<code>&lt;center&gt;</code>, <code>&lt;font&gt;</code>等）。其文件类型描述为：<br><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</code></p>
<p>XHTML 1.0 Frameset（框架版）是参照“HTML 4.01 Frameset”改编，并允许于网页中定义框架元素。其文件类型描述为：<br><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</code></p>
<p>XHTML 1.1。其文件类型描述为：<br><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;</code></p>
<p>XHTML Basic。其文件类型描述为：<br><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML Basic 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd&quot;&gt;</code></p>
<p>另外，在Microsoft Internet Explorer 5.0所新增的<code>&lt;ruby&gt;</code>小字注解标签，在XHTML 1.1得到支持（参看旁注标记）。<br>而第二版的XHTML 1.0于2002年8月成为W3C推荐的文件类型。2.0止于草案。XHTML5不需要DTD。</p>
<h2 id="3-编码与文档类型"><a href="#3-编码与文档类型" class="headerlink" title="3. 编码与文档类型"></a>3. 编码与文档类型</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p>
<p>charset 属性规定 HTML 文档的字符编码</p>
<h4 id="URL-编码"><a href="#URL-编码" class="headerlink" title="URL 编码"></a>URL 编码</h4><p>URL 只能使用 ASCII 字符集来通过因特网进行发送。</p>
<p>由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。</p>
<p>URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。</p>
<p>URL 不能包含空格。URL 编码通常使用 + 来替换空格。</p>
<h3 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h3><p><code>&lt;!DOCTYPE&gt;</code>声明帮助浏览器正确地显示网页。</p>
<p>Web 世界中存在许多不同的文档。只有了解文档的类型，浏览器才能正确地显示文档。</p>
<p>HTML 也有多个不同的版本，只有完全明白页面中使用的确切 HTML 版本，浏览器才能完全正确地显示出 HTML 页面。这就是 &lt;!DOCTYPE&gt; 的用处。</p>
<p><code>&lt;!DOCTYPE&gt;</code>不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的。</p>
<h2 id="4-HTML-字符实体-amp-标签语法-amp-注释"><a href="#4-HTML-字符实体-amp-标签语法-amp-注释" class="headerlink" title="4. HTML 字符实体 &amp; 标签语法 &amp; 注释"></a>4. HTML 字符实体 &amp; 标签语法 &amp; 注释</h2><h3 id="HTML-字符实体"><a href="#HTML-字符实体" class="headerlink" title="HTML 字符实体"></a>HTML 字符实体</h3><p><a href="http://www.runoob.com/html/html-entities.html" target="_blank" rel="external">HTML 字符实体</a></p>
<p>HTML 中的预留字符必须被替换为字符实体。</p>
<p>一些在键盘上找不到的字符也可以使用字符实体来替换。</p>
<p>在 HTML 中，某些字符是预留的。</p>
<p>在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。</p>
<p>如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。 字符实体类似这样：<code>&amp;entity_name;</code>或<code>&amp;#entity_number;</code>;</p>
<p>如需显示小于号，我们必须这样写：<code>&amp;lt;</code> 或 <code>&amp;#60;</code> 或 <code>&amp;#060;</code></p>
<p>HTML 中的常用字符实体是不间断空格(<code>&amp;nbsp;</code>)。</p>
<p>浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。如需在页面中增加空格的数量，您需要使用 <code>&amp;nbsp;</code> 字符实体。</p>
<h3 id="标签语法"><a href="#标签语法" class="headerlink" title="标签语法"></a>标签语法</h3><p>HTML通过标签来定义文档结构</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><code>&lt;!--  --&gt;</code></p>
<h1 id="二、元素"><a href="#二、元素" class="headerlink" title="二、元素"></a>二、元素</h1><h2 id="1-元素类型"><a href="#1-元素类型" class="headerlink" title="1. 元素类型"></a>1. 元素类型</h2><ol>
<li><p>inline：内联元素。<br>本质特点：默认baseline对齐，且content尺寸刚好包含文本（所以设置width、height无效），故不单独占据整行。</p>
</li>
<li><p>block：块元素。<br>本质特点：单独占据一整行，该行行高为该块元素高度。</p>
</li>
<li><p>inline-block：内联块元素。<br>本质特点：兼具inline元素与block元素的一些特点，表现为：对自身而言仍是块元素，对一整行而言，又被视为内联元素，可并排处于同一行。</p>
</li>
</ol>
<h2 id="2-块元素与行内元素"><a href="#2-块元素与行内元素" class="headerlink" title="2. 块元素与行内元素"></a>2. 块元素与行内元素</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements#%E5%85%83%E7%B4%A0%E5%88%97%E8%A1%A8" target="_blank" rel="external">块级元素</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elemente" target="_blank" rel="external">行内元素</a></p>
<h2 id="3-常见标签-amp-超链接"><a href="#3-常见标签-amp-超链接" class="headerlink" title="3. 常见标签 &amp; 超链接"></a>3. 常见标签 &amp; 超链接</h2><p><a href="http://www.runoob.com/tags/ref-byfunc.html" target="_blank" rel="external">HTML 标签列表</a></p>
<h2 id="4-表格-Table"><a href="#4-表格-Table" class="headerlink" title="4. 表格 Table"></a>4. 表格 Table</h2><p><a href="http://www.ruanyifeng.com/blog/2009/05/html_table_mastering.html" target="_blank" rel="external">精通HTML表格的使用</a><br><a href="http://www.runoob.com/html/html-tables.html" target="_blank" rel="external">HTML 表格</a></p>
<h2 id="5-列表类元素"><a href="#5-列表类元素" class="headerlink" title="5. 列表类元素"></a>5. 列表类元素</h2><p><a href="http://www.runoob.com/html/html-lists.html" target="_blank" rel="external">HTML 列表</a></p>
<ol>
<li><p>无序列表</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有序列表</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义列表</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>- black hot drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>- white cold drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="6-图片元素-img"><a href="#6-图片元素-img" class="headerlink" title="6. 图片元素 img"></a>6. 图片元素 img</h2><p><a href="http://www.runoob.com/html/html-images.html" target="_blank" rel="external">HTML 图像</a></p>
<h2 id="7-表单类元素-标题和段落元素、语义化及正确性、新增标签和元素"><a href="#7-表单类元素-标题和段落元素、语义化及正确性、新增标签和元素" class="headerlink" title="7. 表单类元素: 标题和段落元素、语义化及正确性、新增标签和元素"></a>7. 表单类元素: 标题和段落元素、语义化及正确性、新增标签和元素</h2><p><a href="http://www.runoob.com/html/html-forms.html" target="_blank" rel="external">HTML 表单和输入</a><br><a href="http://www.runoob.com/html/html5-form-elements.html" target="_blank" rel="external">HTML5 表单元素</a><br><a href="http://www.runoob.com/html/html5-semantic-elements.html" target="_blank" rel="external">HTML5 语义元素</a><br><a href="http://www.runoob.com/html/html5-new-element.html" target="_blank" rel="external">HTML5 新元素</a></p>
<h2 id="8-表单与文件"><a href="#8-表单与文件" class="headerlink" title="8. 表单与文件"></a>8. 表单与文件</h2><p><a href="http://www.cnblogs.com/zichi/p/html5-file-api.html" target="_blank" rel="external">HTML5 File API — 让前端操作文件变的可能</a></p>
<h1 id="三、CSS"><a href="#三、CSS" class="headerlink" title="三、CSS"></a>三、CSS</h1><p><a href="http://www.runoob.com/css/css-tutorial.html" target="_blank" rel="external">CSS 教程</a></p>
<h2 id="1-什么是-CSS-amp-CSS-语法"><a href="#1-什么是-CSS-amp-CSS-语法" class="headerlink" title="1. 什么是 CSS &amp; CSS 语法"></a>1. 什么是 CSS &amp; CSS 语法</h2><ul>
<li>CSS 指层叠样式表 (Cascading Style Sheets)</li>
<li>样式定义如何显示 HTML 元素</li>
<li>样式通常存储在样式表中</li>
<li>把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题</li>
<li>外部样式表可以极大提高工作效率</li>
<li>外部样式表通常存储在 CSS 文件中</li>
<li>多个样式定义可层叠为一</li>
</ul>
<p><a href="http://www.runoob.com/css/css-syntax.html" target="_blank" rel="external">CSS 语法</a></p>
<h2 id="2-如何将-CSS-应用到网页"><a href="#2-如何将-CSS-应用到网页" class="headerlink" title="2. 如何将 CSS 应用到网页"></a>2. 如何将 CSS 应用到网页</h2><p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt;</code></p>
<h2 id="3-CSS-选择符-class-和-id"><a href="#3-CSS-选择符-class-和-id" class="headerlink" title="3. CSS 选择符:class 和 id"></a>3. CSS 选择符:class 和 id</h2><p><a href="http://www.runoob.com/css/css-id-class.html" target="_blank" rel="external">CSS Id 和 Class</a></p>
<h2 id="4-font-类属性-amp-text-类属性"><a href="#4-font-类属性-amp-text-类属性" class="headerlink" title="4. font 类属性 &amp; text 类属性"></a>4. font 类属性 &amp; text 类属性</h2><p><a href="http://www.runoob.com/css/css-font.html" target="_blank" rel="external">CSS 字体</a><br><a href="http://www.runoob.com/css/css-text.html" target="_blank" rel="external">CSS 文本格式</a></p>
<h2 id="5-background-背景属性"><a href="#5-background-背景属性" class="headerlink" title="5. background 背景属性"></a>5. background 背景属性</h2><p><a href="http://www.runoob.com/css/css-background.html" target="_blank" rel="external">CSS 背景</a></p>
<h2 id="6-border-边框属性"><a href="#6-border-边框属性" class="headerlink" title="6. border 边框属性"></a>6. border 边框属性</h2><p><a href="http://www.runoob.com/css/css-border.html" target="_blank" rel="external">CSS 边框</a></p>
<h2 id="7-float-浮动"><a href="#7-float-浮动" class="headerlink" title="7. float 浮动"></a>7. float 浮动</h2><p><a href="http://www.runoob.com/css/css-float.html" target="_blank" rel="external">CSS Float(浮动)</a></p>
<h2 id="8-position-定位"><a href="#8-position-定位" class="headerlink" title="8. position 定位"></a>8. position 定位</h2><p><a href="http://www.runoob.com/css/css-positioning.html" target="_blank" rel="external">CSS Positioning(定位)</a></p>
<h2 id="9-盒模型"><a href="#9-盒模型" class="headerlink" title="9. 盒模型"></a>9. 盒模型</h2><p><a href="http://www.runoob.com/css/css-boxmodel.html" target="_blank" rel="external">CSS 盒子模型</a></p>
<h2 id="10-补白"><a href="#10-补白" class="headerlink" title="10. 补白"></a>10. 补白</h2><p><a href="http://www.runoob.com/css/css-margin.html" target="_blank" rel="external">CSS Margin(外边距)</a><br><a href="http://www.runoob.com/css/css-padding.html" target="_blank" rel="external">CSS Padding（填充）</a></p>
<h2 id="11-浏览器兼容性"><a href="#11-浏览器兼容性" class="headerlink" title="11. 浏览器兼容性"></a>11. 浏览器兼容性</h2><p><a href="https://www.jianshu.com/p/eba18372a3c1" target="_blank" rel="external">浏览器兼容性问题及解决方案(CSS部分)</a><br><a href="http://www.imooc.com/article/3513" target="_blank" rel="external">不同浏览器兼容性——常用的CSS Hack技术集锦</a><br><a href="https://juejin.im/post/59a3f2fe6fb9a0249471cbb4" target="_blank" rel="external">浏览器兼容性问题解决方案 · 总结</a></p>
<h1 id="四、JavaScript"><a href="#四、JavaScript" class="headerlink" title="四、JavaScript"></a>四、JavaScript</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="external">JavaScript MDN</a></p>
<h2 id="1-JavaScript-基础"><a href="#1-JavaScript-基础" class="headerlink" title="1. JavaScript 基础"></a>1. JavaScript 基础</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web/JavaScript_basics" target="_blank" rel="external">JavaScript 基础</a></p>
<h2 id="2-JavaScript-数据类型"><a href="#2-JavaScript-数据类型" class="headerlink" title="2. JavaScript 数据类型"></a>2. JavaScript 数据类型</h2><p><a href="http://www.runoob.com/js/js-datatypes.html" target="_blank" rel="external">JavaScript 数据类型</a></p>
<h2 id="3-语句、表达式和运算符"><a href="#3-语句、表达式和运算符" class="headerlink" title="3. 语句、表达式和运算符"></a>3. 语句、表达式和运算符</h2><p><a href="http://www.runoob.com/js/js-statements.html" target="_blank" rel="external">JavaScript 语句</a><br><a href="http://www.runoob.com/js/js-operators.html" target="_blank" rel="external">JavaScript 运算符</a></p>
<h2 id="4-变量与函数"><a href="#4-变量与函数" class="headerlink" title="4. 变量与函数"></a>4. 变量与函数</h2><p><a href="http://www.runoob.com/js/js-variables.html" target="_blank" rel="external">JavaScript 变量</a><br><a href="http://www.runoob.com/js/js-functions.html" target="_blank" rel="external">JavaScript 函数</a></p>
<h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h2><p><a href="http://www.runoob.com/js/js-obj-array.html" target="_blank" rel="external">JavaScript Array（数组） 对象</a></p>
<h2 id="6-JSON"><a href="#6-JSON" class="headerlink" title="6. JSON"></a>6. JSON</h2><p><a href="http://www.runoob.com/js/js-json.html" target="_blank" rel="external">JavaScript JSON</a></p>
<h2 id="7-日期处理"><a href="#7-日期处理" class="headerlink" title="7. 日期处理"></a>7. 日期处理</h2><p><a href="http://www.runoob.com/js/js-obj-date.html" target="_blank" rel="external">JavaScript Date（日期） 对象</a></p>
<h2 id="8-DOM-amp-BOM"><a href="#8-DOM-amp-BOM" class="headerlink" title="8. DOM &amp; BOM"></a>8. DOM &amp; BOM</h2><p><a href="http://www.runoob.com/js/js-htmldom.html" target="_blank" rel="external">JavaScript HTML DOM</a><br><a href="http://www.runoob.com/js/js-window.html" target="_blank" rel="external">JavaScript Window - 浏览器对象模型</a></p>
<h2 id="9-事件"><a href="#9-事件" class="headerlink" title="9. 事件"></a>9. 事件</h2><p><a href="http://www.runoob.com/js/js-events.html" target="_blank" rel="external">JavaScript 事件</a></p>
<h2 id="10-正则表达式"><a href="#10-正则表达式" class="headerlink" title="10. 正则表达式"></a>10. 正则表达式</h2><p><a href="http://www.runoob.com/js/js-regexp.html" target="_blank" rel="external">JavaScript 正则表达式</a></p>
<h2 id="11-encode、decode"><a href="#11-encode、decode" class="headerlink" title="11. encode、decode"></a>11. encode、decode</h2><p><a href="http://www.cnblogs.com/luckyuns/p/6396701.html" target="_blank" rel="external">js 中编码（encode）和解码（decode）的三种方法</a></p>
<h2 id="12-对象"><a href="#12-对象" class="headerlink" title="12. 对象"></a>12. 对象</h2><p><a href="http://www.runoob.com/js/js-obj-intro.html" target="_blank" rel="external">JavaScript 对象</a></p>
<h2 id="13-作用域链"><a href="#13-作用域链" class="headerlink" title="13. 作用域链"></a>13. 作用域链</h2><p><a href="http://www.runoob.com/js/js-scope.html" target="_blank" rel="external">JavaScript 作用域</a></p>
<h2 id="14-原型链"><a href="#14-原型链" class="headerlink" title="14. 原型链"></a>14. 原型链</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="external">继承与原型链</a></p>
<h2 id="15-构造函数"><a href="#15-构造函数" class="headerlink" title="15. 构造函数"></a>15. 构造函数</h2><p><a href="https://www.jianshu.com/p/322b90d489b8" target="_blank" rel="external">Javascript构造函数和原型</a></p>
<h2 id="16-执行上下文栈与执行上下文"><a href="#16-执行上下文栈与执行上下文" class="headerlink" title="16. 执行上下文栈与执行上下文"></a>16. 执行上下文栈与执行上下文</h2><p><a href="https://segmentfault.com/a/1190000009041008" target="_blank" rel="external">深入理解JavaScript执行上下文、函数堆栈、提升的概念</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/8" target="_blank" rel="external">JavaScript深入之执行上下文</a><br><a href="https://juejin.im/entry/599e949251882524472239c4" target="_blank" rel="external">JavaScript 中的执行上下文和调用栈是什么？</a></p>
<h2 id="17-变量对象与活动对象"><a href="#17-变量对象与活动对象" class="headerlink" title="17. 变量对象与活动对象"></a>17. 变量对象与活动对象</h2><p><a href="https://segmentfault.com/a/1190000010339180" target="_blank" rel="external">关于javascript中的变量对象和活动对象</a><br><a href="http://www.cnblogs.com/ivehd/p/vo_ao.html" target="_blank" rel="external">图解Javascript——变量对象和活动对象</a><br><a href="https://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html" target="_blank" rel="external">深入理解JavaScript系列（12）：变量对象（Variable Object）</a></p>
<h2 id="18-闭包"><a href="#18-闭包" class="headerlink" title="18. 闭包"></a>18. 闭包</h2><p><a href="http://www.runoob.com/js/js-function-closures.html" target="_blank" rel="external">JavaScript 闭包</a></p>
<h2 id="19-this"><a href="#19-this" class="headerlink" title="19. this"></a>19. this</h2><p><a href="https://www.ibm.com/developerworks/cn/web/1207_wangqf_jsthis/index.html" target="_blank" rel="external">深入浅出 JavaScript 中的 this</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external">this</a></p>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
            <tag> JS </tag>
            
            <tag> HTML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript高级程序设计读书笔记（一）]]></title>
      <url>/2018/01/14/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%89%E7%89%88%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<h1 id="一、JavaScript-简介"><a href="#一、JavaScript-简介" class="headerlink" title="一、JavaScript 简介"></a>一、JavaScript 简介</h1><ol>
<li>虽然JavaScript和ECMAScript通常都被人们用来表达相同的含义，但JavaScript的含义却比ECMA-262中规定的要多得多。一个完整的JavaScript应该由下面三个不同的部分组成<ul>
<li><strong>核心（ECMAScript）</strong>: 由ECMA-262定义，提供核心语言功能</li>
<li><strong>文档对象模型（DOM）</strong>: 提供访问和操作网页内容的方法和接口。DOM1、DOM2、DOM3，功能目标依次更加宽泛</li>
<li><strong>浏览器对象模型（BOM）</strong>: 提供与浏览器交互的方法和接口</li>
</ul>
</li>
</ol>
<h1 id="二、在HTML中使用JavaScript"><a href="#二、在HTML中使用JavaScript" class="headerlink" title="二、在HTML中使用JavaScript"></a>二、在HTML中使用JavaScript</h1><ol>
<li>所有<code>script</code>元素都会按照他们在页面中出现的先后顺序依次被解析。在不使用<code>defer</code>和<code>async</code>属性的情况下，只有在解析完前面<code>script</code>元素中的代码之后，才会开始解析后面<code>script</code>元素中的代码</li>
<li><code>defer</code>告诉浏览器立即下载，但脚本会被延迟到整个页面都解析完毕后再运行</li>
<li><code>async</code>，一旦脚本可用，会异步执行，不会阻塞页面的渲染</li>
<li><code>defer</code>和<code>async</code>都只适用于外部脚本</li>
</ol>
<h1 id="三、基本概念"><a href="#三、基本概念" class="headerlink" title="三、基本概念"></a>三、基本概念</h1><ol>
<li>区分大小写</li>
<li>标示符：<ul>
<li>第一个字符必须是一个字母、下划线(_)或一个美元符号($)</li>
<li>其他字母可以是字母、下划线、美元符号或数字</li>
</ul>
</li>
<li><code>var</code>声明的变量<del>是当前作用域的变量</del>会被自动添加到最接近的环境中，不使用<code>var</code>声明的是全局变量</li>
<li>5种简单数据类型(基本数据类型): <code>Undefined</code>, <code>Null</code>, <code>Boolean</code>, <code>Number</code>, <code>String</code>；1种复杂数据类型：<code>Object</code></li>
<li><code>typeof</code>是一个操作符而不是一个函数</li>
<li><code>3.215e7</code> <code>3e-17</code></li>
<li><code>0.1 + 0.2 = 0.30000000000000004</code></li>
<li><code>NaN</code>不等于任何值，包括它本身，我们用<code>isNaN()</code>来判断某个变量是否”<strong>不是数值</strong>“</li>
<li>基于对象调用<code>isNaN()</code>时，先会调用对象的<code>valueOf()</code>方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用<code>toString()</code>方法，再测试返回值</li>
<li>数值转换：<code>Number()</code>, <code>parseInt()</code>, <code>parseFloat()</code></li>
<li><p>调用数值的<code>toString()</code>方法时，可以传递一个参数：输出数值的基数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">num.toString(); <span class="comment">// "10"</span></span><br><span class="line">num.toString(<span class="number">2</span>); <span class="comment">// "1010"</span></span><br><span class="line">num.toString(<span class="number">8</span>); <span class="comment">// "12"</span></span><br><span class="line">num.toString(<span class="number">10</span>); <span class="comment">// "10"</span></span><br><span class="line">num.toString(<span class="number">16</span>); <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>位操作符</p>
<ul>
<li><code>~</code>: 按位非(NOT)，返回数值的反码</li>
<li><code>&amp;</code>: 按位与(AND)</li>
<li><code>|</code>: 按位或(OR)</li>
<li><code>^</code>: 按位异或(XOR)</li>
<li><code>&lt;&lt;</code>: 左移</li>
<li><code>&gt;&gt;</code>: 有符号右移，即移动的时候保留符号位，符号位不参与移动</li>
<li><code>&gt;&gt;&gt;</code>: 无符号右移，即符号位参与移动</li>
</ul>
</li>
<li>逻辑与与逻辑或都属于短路操作，即如果第一个操作数能够决定结果，<strong>那么就不会对第二个操作数进行求值</strong></li>
<li><code>break</code>: 立即退出循环，强制继续执行循环后面的语句；<code>continue</code>: 立即退出循环，但退出循环后从循环的顶部继续执行</li>
<li>ECMAScript中的参数在内部是用一个数组来表示的</li>
</ol>
<h1 id="四、变量、作用域和内存问题"><a href="#四、变量、作用域和内存问题" class="headerlink" title="四、变量、作用域和内存问题"></a>四、变量、作用域和内存问题</h1><ol>
<li>ECAMScript中所有函数的参数都是<strong>按值传递的</strong><blockquote>
<p>经过查阅思考后，暂时得出结论：<strong>js中所有变量都是按值传递的，按值传递我理解为<code>a = b</code>，b把他的值复制一份传给a，这两个值互相独立，互不干扰</strong>。<br>对值类型，变量的值直接存在栈内存中，读取的时候直接去该变量对应的栈内存位置读取；对引用类型，变量对应的栈内存位置存的是实际值的堆内存地址，实际值存在堆内存中，读取的时候先去该变量的栈内存位置找到堆内存地址，然后根据这个地址去堆内存中找到实际的值，也就是引用类型的储存和读取都多了一步。所以在变量的复制时，传递的都是变量对应栈内存中储存的东西，值类型就直接是变量的值，复制完互不干扰；引用类型复制的就是内存地址，复制完也互不干扰，但读取的时候相同内存地址的值仍然是相同的。而参数的传递也就是从实参到形参的复制<br>参考资料：<a href="https://juejin.im/entry/589c29a9b123db16a3c18adf" target="_blank" rel="external">前端基础进阶：详细图解 JavaScript 内存空间</a> |  <a href="https://github.com/mqyqingfeng/Blog/issues/10" target="_blank" rel="external">JavaScript深入之参数按值传递 </a></p>
</blockquote>
</li>
<li><strong>执行环境</strong>(execution context)定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的<strong>变量对象</strong>(variable object)，环境定义的所有变量和函数都会保存在这个对象中。虽然我们无法访问这个对象，但解析器在处理数据时会在后台使用它</li>
<li>每个函数都有自己的<strong>执行环境</strong>，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行后，栈将其环境弹出，把控制权返还给之前的执行环境</li>
<li>当代码在一个环境中执行时，会创建对象的一个<strong>作用域链</strong>(scope chain)，作用域链用来保证对执行环境有权访问的所有变量和函数的<strong>有序访问</strong>。作用域链的前端始终都是当前执行代码所在环境的<strong>变量对象</strong>。如果这个环境是函数，则将其<strong>活动对象</strong>(activation object)作为变量对象。活动对象最开始只包含一个变量，即<code>arguments</code>对象(在全局环境中是不存在的)。作用域链中的下一个变量对象来自包含(外部)环境，而在下一个变量对象则来自下一个包含环境。这样一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象</li>
<li><strong>标示符</strong>的解析是从作用域的前端开始，逐级的向后回溯，直到找到标示符为止</li>
<li><code>try-catch</code>中的<code>catch</code>块和<code>with</code>语句会在作用域的前端临时增加一个变量对象，该变量对象会在代码执行后被移除<ul>
<li><code>catch</code>：创建一个新的变量对象放在前端，其中包含的是被抛出的错误对象的声明</li>
<li><code>with</code>：会将指定的对象添加到前端</li>
</ul>
</li>
<li>ES5之前没有块级作用域，ES6开始有了块级作用域(需使用<code>let</code>和<code>const</code>)</li>
<li>JS具有自动垃圾收集机制。原理很简单，找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔(或代码执行中预定的收集时间)，周期性的执行这一操作</li>
<li>用于标记无用变量的策略会因实现而异，但具体到浏览器中的实现，通常有两个策略：<ul>
<li><strong>标记清除</strong>：最常用的垃圾收集方式，当变量进入环境时标记为”进入环境”，离开环境时标记为”离开环境”</li>
<li><strong>引用计数</strong>：跟踪记录每个值被引用的次数，当变成0的时候就可以回收。但如果用到<strong>循环引用</strong>的话就会出现问题</li>
</ul>
</li>
<li>确定一个值是哪种基本类型可以使用<code>typeof</code>操作符；而确定一个值是哪种引用类型可以使用<code>instanceof</code>操作符</li>
<li>变量的执行环境有助于确定应该何时释放内存</li>
<li>解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效的回收内存，应该及时解除不再使用的全局变量、全局对象属性以及循环引用变量的引用</li>
</ol>
<h1 id="五、引用类型"><a href="#五、引用类型" class="headerlink" title="五、引用类型"></a>五、引用类型</h1><ol>
<li>数组的<code>length</code>属性很有特点——<strong>他不是只读的</strong>。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项</li>
<li>检测数组：正常我们使用<code>value instanceof Array</code>来判断一个变量是否是数组，但这假定是在单一的全局执行环境下，如果网页包含多个框架，那实际上就存在两个版本以上不同的全局执行环境，从而存在两个以上不同版本的<code>Array</code>构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有不同的构造函数。为了解决这个问题，ECMAScript 5新增了一个方法<code>Array.isArray()</code>，用来检测一个变量是否是数组，无论它是在哪个全局执行环境中创建的</li>
<li>数组的<code>toLocaleString()</code>、<code>toString()</code>、<code>valueOf()</code>方法分别会调用数组中每一项的<code>toLocaleString()</code>、<code>toString()</code>、<code>valueOf()</code>方法；<code>push()</code>和<code>unshift()</code>方法可以接受多个参数；<code>sort()</code>默认升序排列数组项，并调用每一项的<code>toString()</code>，即使是数值类型，可以穿入一个比较函数<code>(a,b) =&gt; {return }</code>，如果a应该在b前面返回负数，如果两个参数相等返回0(<strong>???</strong>)，如果a应该在b后面返回正数</li>
<li><p>数组的<code>concat</code>方法连接数组实际上是连接数组的浅拷贝，<strong>如果你连接的数组里面包引用类型</strong>，如果你改变原引用，连接后的引用也会改变</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, <span class="number">2</span>],</span><br><span class="line">    b = [[<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>];</span><br><span class="line">c = a.concat(b); <span class="comment">// [&#123;a: 1&#125;, 2, [3, 4], 5]</span></span><br><span class="line">a[<span class="number">0</span>].b = <span class="number">2</span>; <span class="comment">// [&#123;a: 1, b: 2&#125;, 2, [3, 4], 5]</span></span><br><span class="line">b[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">233</span>; <span class="comment">// [&#123;a: 1, b: 2&#125;, 2, [233, 4], 5]</span></span><br><span class="line">b = [<span class="number">3</span>,<span class="number">4</span>]; <span class="comment">// 注意这里b失去了对原引用的绑定，所以c没有变化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组<code>reduce</code>和<code>reduceRight</code>如果不传入第二个参数，迭代从数组第二项开始；如果传入第二个参数，迭代从数组第一项开始</p>
</li>
<li>由于传递给RegExp函数的参数是字符串(不能传递表达式字面量)，所以某些情况下需要对字符进行双重转义，如：字面量<code>/\[bc\]at/</code>，等价的字符串<code>&quot;/\\[bc\\]at/&quot;</code>；而且使用字面量和使用RegExp构造函数创建的正则表达式不一样，在ECMAScript 3中，正则表达式字面量始终共享一个RegExp实例，而使用构造函数创建的每一个实例都是一个新实例(<strong>在ECMAScript 5中做了修改，使用字面量必须像直接调用构造函数一样，每次都创建新的RegExp实例</strong>)</li>
<li><code>exc()</code>方法在不设置全局标志的情况下，在同一个字符串上多次调用<code>exec()</code>始终会返回第一个匹配项的信息；在设置全局标志的情况下，每次调用<code>exec()</code>都会在字符串中继续查找新匹配项。同时它的<code>lastIndex</code>(代表开始搜索下一个匹配项的字符位置)会发生变化</li>
<li>ECMAScript中没有函数重载</li>
<li>实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用(可以访问)；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行</li>
<li>函数的名字仅仅是一个包含指针的变量而已</li>
<li><code>arguments</code>是一个类数组对象，包含着传入函数中的所有参数，它还有一个名叫<code>callee</code>的属性，该属性是一个指针，指向拥有这<code>arguments</code>对象的函数，通过<code>arguments.callee</code>可以解除该函数与函数名的耦合</li>
<li><code>caller</code>是函数对象的一个属性，保存着调用当前函数的函数的引用</li>
<li>函数的<code>length</code>属性表示函数希望接收的命名参数的个数</li>
<li><code>prototype</code>属性不可枚举，使用<code>for-in</code>无法发现</li>
<li><code>apply</code>的第一个参数用来设置函数体内部<code>this</code>对象的值；第二个参数是一个数组，用来表示传入函数的参数</li>
<li><code>call</code>的第一个参数和<code>apply</code>的一样，与之不同的是接下来的参数用来表示传入函数的参数，即传给函数的参数必须逐个列举出来</li>
<li>传递参数并非是<code>apply</code>和<code>call</code>真正的用武之地：他们真正强大的地方是能够扩充函数赖以运行的作用域，即可以指定函数的<code>this</code></li>
<li><code>bind</code>用来绑定函数的<code>this</code></li>
<li><p>三种基本包装类型：<code>Boolean</code>、<code>Number</code>、<code>String</code>。当第二行访问s1时，访问过程处于一种访问模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理：</p>
<ol>
<li>创建<code>String</code>类型的一个实例</li>
<li>在实例上调用指定的方法</li>
<li>销毁这个实例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'some text'</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>也是经过这种处理，js中的基本类型就变得和对象一样拥有各种方法和属性了</strong></p>
</li>
<li><p>引用类型和基本包装类型的主要区别就是<strong>对象的生存期</strong>，使用<code>new</code>操作符创建的引用类型的实例，在执行流离开当前作用域前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即销毁。这意味着我们不能在运行时为基本类型值添加属性和方法<br>21.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">'25'</span>;</span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value); <span class="comment">// 转型函数</span></span><br><span class="line"><span class="keyword">typeof</span> number; <span class="comment">// 'number'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">'value'</span>); <span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">typeof</span> obj; <span class="comment">// 'object'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Number</code>类型的几个方法</p>
<ul>
<li><code>toFixed</code>: 按照指定的小数位返回数值的字符串表示</li>
<li><code>toExponential</code>: 返回1以指数表示法(e表示法)表示的数值的字符串形式，接收一个参数指定输出结果中的小数位数</li>
<li><code>toPrecision</code>: 返回合适的数值的字符串表示，可能固定大小格式，可能指数格式，接受一个参数指定表示数值的所有数字的位数(不包括指数部分)</li>
</ul>
</li>
<li><p><code>Global</code>对象是ECMAScript中最特别的一个对象了，因为不管你从什么角度看，这个对象都是不存在的。ECMAScript中的<code>Global</code>对象在某种意义上是作为一个终极的”兜底儿对象”来定义的。换句话说，不属于任何其他对象的方法和属性，最终都是作为它的属性和方法。事实上，没有全局对象和全局函数；所有在全局作用域中定义的属性和函数，都是<code>Global</code>对象的属性。诸如<code>isNaN()</code>，<code>isFinite()</code>，<code>parseInt()</code>以及<code>parseFloat()</code>，实际上都是<code>Global</code>对象的方法。除此之外，<code>Global</code>对象还包含其他一些方法：</p>
<ul>
<li>URL编码方法：<code>encodeURI()</code>主要用于整个URL(例如：<a href="http://www.wrox.com/illegal" target="_blank" rel="external">http://www.wrox.com/illegal</a> value.htm)，而<code>encodeURIComponent()</code>主要用于对URL中的某一段(例如前面URL中的illegal value.htm)进行编码。他们的主要区在于，<code>encodeURI()</code>不会对本身属于URL的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而<code>encodeURIComponent()</code>则对它发现的任何非标准字符进行编码。例如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">'http://www.wrox.com/illegal value.htm#start'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">encodeURI</span>(uri); <span class="comment">// 'http://www.wrox.com/illegal%20value.htm#start' 除了空格以外的其他字符都原封不动</span></span><br><span class="line"><span class="built_in">encodeURIComponent</span>(uri); <span class="comment">// 'http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start' 替换所有非字母数字字符</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对应的有<code>decodeURI()</code>和<code>decodeURIComponent()</code>分别用来解码<code>encodeURI()</code>和<code>encodeURIComponent()</code>编码的字符串</p>
<ul>
<li><code>eval()</code></li>
</ul>
</li>
</ol>
<h1 id="六、面向对象的程序设计"><a href="#六、面向对象的程序设计" class="headerlink" title="六、面向对象的程序设计"></a>六、面向对象的程序设计</h1><ol>
<li>对于只有内部才用的特性，规范把它们放在了两个方括号中，例如<code>[[Enumerable]]</code></li>
<li><p>ECMAScript中有两种属性：数据属性和访问器属性</p>
<ul>
<li><p><strong>数据属性</strong>：数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性：</p>
<ol>
<li><code>[[Configurable]]</code>：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问其属性。直接在对象上定义的属性该特性默认值为<code>true</code></li>
<li><code>[[Enumerable]]</code>：表示能否枚举，能否通过<code>for-in</code>循环返回属性。直接在对象上定义的属性该特性默认值为<code>true</code></li>
<li><code>[[Writable]]</code>：表示能否修改属性的值。直接在对象上定义的属性该特性默认值为<code>true</code></li>
<li><code>[[Value]]</code>：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为<code>undefined</code><br>要修改这几个特性，必须使用<code>Object.defineProperty()</code>，如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.definedProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">'hello'</span></span><br><span class="line">&#125;);</span><br><span class="line">person.name; <span class="comment">// 'hello'</span></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line">person.name; <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意，一旦把属性定义为不可配置的，就再也不能把它变回可配置的了</p>
</li>
<li><p><strong>访问器属性</strong>：访问器属性不包含数据值；他们包含一对<code>getter</code>和<code>setter</code>函数(这两个函数都不是必须的)，在读取访问器属性的时候，会调用<code>getter</code>函数，这个函数负责返回有效的值；在写入访问器属性的时候，会调用<code>setter</code>函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性：</p>
<ol>
<li><code>[[Configurable]]</code>：与数据属性的对应特性相同</li>
<li><code>[[Enumerable]]</code>：与数据属性的对应特性相同</li>
<li><code>[[Get]]</code>：在读取属性时调用的函数。默认值为<code>undefined</code></li>
<li><code>[[Set]]</code>：在写入属性时调用的函数。默认值为<code>undefined</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  _year: <span class="number">2004</span>,</span><br><span class="line">  edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">'year'</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._year = newValue;</span><br><span class="line">      <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">book.edition; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>访问器属性不能直接定义，必须使用<code>Object.defineProperty()</code>来定义<br><strong>修改<code>year</code>属性也会同时修改<code>_year</code>和<code>edition</code>的值，这是使用访问器属性的常用方式，即设置一个属性的值会导致其他属性发生变化</strong></p>
</li>
</ul>
</li>
<li>对于<code>Object.defineProperty()</code>方法定义的属性，没有指定的描述符默认值为<code>false</code>或<code>undefined</code></li>
<li><code>Object.defineProperties(obj. props)</code>方法<strong>通过描述符一次定义多个属性</strong></li>
<li><code>Object.getOwnPropertyDescriptor(obj, prop)</code>方法取得给定属性的描述符；<code>Object.getOwnPropertyDescriptors(obj, prop)</code>方法返回所有属性的描述符</li>
<li><p>创建对象：</p>
<ol>
<li><p><strong>工厂模式</strong>：工厂模式虽然解决了创建多个相似对象的问题，但没有解决对象识别的问题(即怎样知道一个对象的类型)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构造函数模式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac 使用记录]]></title>
      <url>/2017/11/08/Mac%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="软件篇"><a href="#软件篇" class="headerlink" title="软件篇"></a>软件篇</h2><h3 id="终端工具-iTerm2"><a href="#终端工具-iTerm2" class="headerlink" title="终端工具 iTerm2"></a>终端工具 iTerm2</h3><p>用于替代Mac原生终端，<a href="https://www.iterm2.com/" target="_blank" rel="external">官网</a>，界面漂亮，色彩丰富，可以选择不同的主题。敲命令时，如果命令正确显示绿色，不正确显示红色。<br><img src="/2017/11/08/Mac 使用记录/iTerm2.jpg" alt="iTerm2"></p>
<h3 id="duet"><a href="#duet" class="headerlink" title="duet"></a>duet</h3><p>把你的iPad/iPhone变成一个额外的显示器，<a href="https://www.duetdisplay.com/cn/" target="_blank" rel="external">官网</a>。<strong>然而买了之后并没有怎么使用</strong><br><img src="/2017/11/08/Mac 使用记录/duet.jpg" alt="duet"></p>
<h3 id="网易有道词典"><a href="#网易有道词典" class="headerlink" title="网易有道词典"></a>网易有道词典</h3><p>平时查查单词之类的，<a href="http://cidian.youdao.com/multi.html" target="_blank" rel="external">官网</a><br><img src="/2017/11/08/Mac 使用记录/dictionary.jpg" alt="有道词典"></p>
<h3 id="Geekbench-4"><a href="#Geekbench-4" class="headerlink" title="Geekbench 4"></a>Geekbench 4</h3><p>用来测试电脑的性能，<a href="http://www.geekbench.com/" target="_blank" rel="external">官网</a><br><img src="/2017/11/08/Mac 使用记录/Geekbench4.jpg" alt="Geekbench4"></p>
<h3 id="Blackmagic-Disk-Speed-Test"><a href="#Blackmagic-Disk-Speed-Test" class="headerlink" title="Blackmagic Disk Speed Test"></a>Blackmagic Disk Speed Test</h3><p>用来测试你的硬盘速度，<a href="https://itunes.apple.com/us/app/blackmagic-disk-speed-test/id425264550?mt=12" target="_blank" rel="external">网页</a><br><img src="/2017/11/08/Mac 使用记录/DiskSpeedTest.jpg" alt="Blackmagic Disk Speed Test"></p>
<h3 id="DaisyDisk"><a href="#DaisyDisk" class="headerlink" title="DaisyDisk"></a>DaisyDisk</h3><p>以图形的方式直观的展现你的硬盘使用情况，<a href="https://daisydiskapp.com/" target="_blank" rel="external">官网</a><br><img src="/2017/11/08/Mac 使用记录/DaisyDisk.jpg" alt="DaisyDisk"></p>
<h3 id="WebDrop"><a href="#WebDrop" class="headerlink" title="WebDrop"></a>WebDrop</h3><p>平时在电脑上看到好的网页突然想在手机上看的时候，如果你用的是Safari，直接可以用AirDrop分享给手机。但Chrome就不可以了，这款软件就是来解决这个痛点的。通过这款软件你可以把当前的Chrome网页经由AirDrop分享出去。<a href="https://github.com/JustinFincher/WebDrop" target="_blank" rel="external">官网</a><br><em>注：但后来我发现了Mac的handoff，Chrome也支持了，只要你的Mac/iPad/iPhone打开蓝牙，当你在某个设备浏览网页的时候，其他设备会有提示按钮，点击就会进入到对应的网页。很是方便。<a href="http://www.playpcesor.com/2015/01/handoff-chrome-ios-mac.html" target="_blank" rel="external">设置方法</a></em><br><img src="/2017/11/08/Mac 使用记录/webDrop.jpg" alt="WebDrop"></p>
<h3 id="SizeUp"><a href="#SizeUp" class="headerlink" title="SizeUp"></a>SizeUp</h3><p>刚从Window转到Mac时有很多不适应的地方，如果在Window下，鼠标拖动窗口到屏幕边缘，窗口会自动变化大小停靠在上面。而Mac下则不行。SizeUp这款软件就是通过快捷键来将当前窗口固定到屏幕的不同区域。<a href="http://www.irradiatedsoftware.com/sizeup/" target="_blank" rel="external">官网</a><br><img src="/2017/11/08/Mac 使用记录/sizeup.jpg" alt="SizeUp"></p>
<h3 id="Pap-er"><a href="#Pap-er" class="headerlink" title="Pap.er"></a>Pap.er</h3><p>使用过几款Mac上的壁纸软件，还是这个最吸引我。界面简洁，一目了然，壁纸也都很好看。<a href="http://paper.meiyuan.in/index.html" target="_blank" rel="external">官网</a><br><img src="/2017/11/08/Mac 使用记录/paper.jpg" alt="Pap.er"></p>
<h3 id="The-Unarchiver"><a href="#The-Unarchiver" class="headerlink" title="The Unarchiver"></a>The Unarchiver</h3><p>一款Mac上的解压缩软件。简洁不做作,功能强大。<a href="https://itunes.apple.com/cn/app/the-unarchiver/id425424353?mt=12" target="_blank" rel="external">网页</a></p>
<h3 id="iStat-Menus"><a href="#iStat-Menus" class="headerlink" title="iStat Menus"></a>iStat Menus</h3><p>用来查看你的电脑运行情况，包括CPU、内存、磁盘、网络、传感器、电池、时间、天气等信息，功能十分强大。<a href="https://bjango.com/mac/istatmenus/" target="_blank" rel="external">官网</a><br><img src="/2017/11/08/Mac 使用记录/istat1.jpg" alt="iStat Menus"><br><img src="/2017/11/08/Mac 使用记录/istat2.jpg" alt="iStat Menus"></p>
<h3 id="CheatSheet"><a href="#CheatSheet" class="headerlink" title="CheatSheet"></a>CheatSheet</h3><p>长按<code>⌘</code>键，就会显示当前软件的快捷键。<a href="https://wwwhttps://atom.io/.mediaatelier.com/CheatSheet/" target="_blank" rel="external">官网</a><br><img src="/2017/11/08/Mac 使用记录/cheatSheet.jpg" alt="CheatSheet"></p>
<h3 id="Copia"><a href="#Copia" class="headerlink" title="Copia"></a>Copia</h3><p>一款剪贴板增强软件，感觉还不错。<a href="http://www.dollaropath.com/copia/" target="_blank" rel="external">官网</a></p>
<h3 id="jietu"><a href="#jietu" class="headerlink" title="jietu"></a>jietu</h3><p>鹅厂的一款截图工具，可以在截完后进行简单的操作。<a href="https://itunes.apple.com/cn/app/%E6%88%AA%E5%9B%BE-jietu-%E5%BF%AB%E9%80%9F%E6%A0%87%E6%B3%A8-%E4%BE%BF%E6%8D%B7%E5%88%86%E4%BA%AB%E7%9A%84%E6%88%AA%E5%B1%8F%E5%B7%A5%E5%85%B7/id1059334054?mt=12" target="_blank" rel="external">网页</a><br><img src="/2017/11/08/Mac 使用记录/jietu.jpg" alt="jietu"></p>
<h3 id="ShadowSocks"><a href="#ShadowSocks" class="headerlink" title="ShadowSocks"></a>ShadowSocks</h3><p>用来科学上网</p>
<h3 id="Proxifier"><a href="#Proxifier" class="headerlink" title="Proxifier"></a>Proxifier</h3><p>让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链.<a href="https://www.proxifier.com/" target="_blank" rel="external">官网</a><br><em>注：但Mac终端不能通过这种方法来科学上网，使用<code>proxychains4</code>来解决</em></p>
<h3 id="AppCleaner"><a href="#AppCleaner" class="headerlink" title="AppCleaner"></a>AppCleaner</h3><p>Mac下卸载软件一般是直接把对应的<code>app</code>文件直接移到废纸篓，但这样往往删除的不彻底，通过这款软件可以很好的卸载软件。<a href="https://freemacsoft.net/appcleaner/" target="_blank" rel="external">官网</a><br><img src="/2017/11/08/Mac 使用记录/appcleaner.jpg" alt="appcleaner"></p>
<h3 id="IINA"><a href="#IINA" class="headerlink" title="IINA"></a>IINA</h3><p>Mac上比较好用的一款视频播放器。<a href="https://lhc70000.github.io/iina/" target="_blank" rel="external">官网</a><br><img src="/2017/11/08/Mac 使用记录/IINA.jpg" alt="IINA"></p>
<h3 id="Free-Download-Manager"><a href="#Free-Download-Manager" class="headerlink" title="Free Download Manager"></a>Free Download Manager</h3><p>Mac上一款比较好用的下载工具。在Mac上百度云客户端下载东西会很慢，可以获取下载链接后通过它来下载，下载速度会提升很多。<a href="https://www.freedownloadmanager.org/" target="_blank" rel="external">官网</a><br><img src="/2017/11/08/Mac 使用记录/freedownload.jpg" alt="Free Download Manager"></p>
<h3 id="Air-Video-HD"><a href="#Air-Video-HD" class="headerlink" title="Air Video HD"></a>Air Video HD</h3><p>让你可以用iPad/iPhone直接看储存在Mac上的视频。<a href="http://www.inmethod.com/airvideohd/index.html;jsessionid=2A117E59F43874E67C37E954AFA8722B" target="_blank" rel="external">官网</a></p>
<h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h3><p>颜值很高的前端编辑器。<a href="https://atom.io/" target="_blank" rel="external">官网</a><br><img src="/2017/11/08/Mac 使用记录/atom.jpg" alt="Atom"></p>
<h3 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h3><p>一款Instagram的Mac客户端。<a href="https://flumeapp.com/" target="_blank" rel="external">官网</a><br><img src="/2017/11/08/Mac 使用记录/flume.jpg" alt="Flume"></p>
<h3 id="BombSquad"><a href="#BombSquad" class="headerlink" title="BombSquad"></a>BombSquad</h3><p>一款很有意思的游戏。可以让你iPhone充当控制器。<a href="https://itunes.apple.com/cn/app/bombsquad/id416482767?mt=12" target="_blank" rel="external">网页</a><br><img src="/2017/11/08/Mac 使用记录/bombSquad.jpg" alt="BombSquad"></p>
<h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><p>macOS 缺失的软件包管理器。<a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="external">官网</a></p>
<h3 id="wine"><a href="#wine" class="headerlink" title="wine"></a>wine</h3><p>可以在Mac上运行exe文件。但不是全能的。<a href="https://www.winehq.org/" target="_blank" rel="external">官网</a><br>运行以下命令即可安装</p>
<ol>
<li><code>brew install ruby</code></li>
<li><code>brew cask install xquartz</code></li>
<li><code>brew install wine</code></li>
<li><code>brew install winetricks</code><br>只需要运行<code>wine 程序名.exe</code>就可以运行对应的exe程序</li>
</ol>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol>
<li>Mac下没有对应的剪切操作。在复制操作<code>Command-C</code>后，<code>Command-V</code>是复制过去，<code>Option-Command-V</code>是剪切过去</li>
<li><code>Command-Shift-.</code>是在Finder下显示/隐藏 隐藏文件</li>
<li>用BootCamp在Mac下安装Windows双系统，很方便。<strong>不过升级到10.13后，在window下不能直接从MacOS启动，需要重启按住<code>option</code>键来选择启动的系统，还没找到原因</strong></li>
<li>Time Machine备份系统很方便，可以完美的恢复到任何已经备份的时间点上面</li>
<li>终端下用在命令后面加上<code>&amp;!</code>来让程序在后台运行且当前终端退出后也不会终止运行</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 杂物间 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 杂物间 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 配置记录]]></title>
      <url>/2017/10/30/Hexo%20%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="为文章添加图片"><a href="#为文章添加图片" class="headerlink" title="为文章添加图片"></a>为文章添加图片</h2><p>1、将hexo的_config.yml中的post_asset_folder值设为true，这样每次新建文章时候_posts文件夹下除了你新建的文章还会有一个和你文章名称一样的文件夹，这个文件夹下可以放置和你文章相关的资源<br>2、运行<code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code><br>3、在引用图片的时候这样写就可以了：<code>![logo](文章名称/logo.jpg)</code></p>
<h2 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a>添加评论功能</h2><p>1、由于maupassant主题评论自带disqus，所以方便很多<br>2、注册disqus的账号，找到Add Disqus To Site。按照指引，需要你填写自己的唯一disqus识别名称。<br>3、将上一步的识别名称填写到主题的_config.yml的disqus后面即可<br>4、如果不是maupassant主题，需要在hexo的配置文件中添加<code>disqus_shortname: 你的disqus识别名称</code></p>
<p>多说配置方式也是一样，注册账号。填写唯一标识就可以了</p>
<h2 id="hexo的备份"><a href="#hexo的备份" class="headerlink" title="hexo的备份"></a>hexo的备份</h2><p>之前不怎么注重备份，在一次恢复系统的时候搞丢了部分本地文件，最后只好自己手动一个一个的恢复。所以自己重要的东西一定要备份好</p>
<ol>
<li>如果是mac系统的话，直接用系统的 Time Machine 在备份系统的时候顺便就会把hexo进行了备份</li>
<li><p>使用插件<code>hexo-git-backup</code>进行备份。<a href="http://hexo.mantoujun.top/2017/04/25/%E5%88%A9%E7%94%A8%20git-backup%20%E6%8F%92%E4%BB%B6%E5%A4%87%E4%BB%BDhexo%E6%95%B0%E6%8D%AE/" target="_blank" rel="external">参考文章</a></p>
<ul>
<li><strong>安装</strong>：<code>npm install hexo-git-backup --save</code>,hexo版本需为<code>3.x.x</code></li>
<li><p><strong>添加配置</strong>：在<code>hexo/_config.yml</code>添加</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">backup:</span><br><span class="line">  type: git</span><br><span class="line">    	message: update xxx <span class="comment">//可选，diy信息</span></span><br><span class="line">    	theme: coney,landscape  <span class="comment">//可选，主题备份</span></span><br><span class="line">  repository:</span><br><span class="line">      github: git@github.com:xxx/xxx.git,branchName <span class="comment">//备份的目的路径，必填branch分支</span></span><br><span class="line">      gitcafe: git@github.com:xxx/xxx.git,branchName <span class="comment">//可选，备份到gitcafe</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用法</strong>：<code>hexo backup</code> OR <code>hexo b</code></p>
</li>
<li><strong>恢复</strong>：<ul>
<li>安装 hexo 环境</li>
<li><code>git clone</code>执行克隆</li>
<li>将 backup（取决于备份时候的设定） 分支复制到 hexo 目录</li>
<li>执行<code>hexo -d</code>, 重新配置账户</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《学习JavaScript数据结构与算法》读书笔记--算法补充知识]]></title>
      <url>/2017/10/09/%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong>递归</strong>是一种解决问题的方法，它解决问题的各个小部分，直到极倔最初的大问题，通常设计函数自身的调用</p>
<p>递归不会一直无限调用下去，一般都会有递归上限</p>
<p><strong>尾递归优化</strong>：ES6有尾递归优化，如果函数最后一个操作是调用递归函数，会通过<strong>跳转指令</strong>而不是<strong>子程序调用</strong>来控制</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划(Dynamic Programming, DP)是一种将复杂问题分解成更小问题来解决的优化技术</p>
<p>要注意动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案；而动态规划是将问题分解成相互依赖的子问题</p>
<p>解决动态规划问题通常需要三个步骤</p>
<ul>
<li>定义子问题</li>
<li>实现要反复执行而解决子问题的部分</li>
<li>识别并求解出边界问题</li>
</ul>
<p>能用动态规划解决的一些著名问题如下：</p>
<ul>
<li><strong>背包问题</strong>：给出一组项目，各自有值和容量，目标是找出总值最大的项目的集合。这个问题的限制是，总容量必须小于等于“背包”的容量</li>
<li><strong>最长公共子序列</strong>：找出一组序列的最长公共子序列(可由另一序列删除元素但不改变余下元素的顺序而得到)</li>
<li><strong>矩阵链相乘</strong>：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法(计算次数尽可能少)。相乘操作不会进行，解决方案是找到这些矩阵各自相乘的顺序</li>
<li><strong>硬币找零</strong>：给出面额为d1…dn的一定数量的硬币和要找零的钱数，找出有多少种找零的方法</li>
<li><strong>图的全源最短路径</strong>：对所有顶点对(u, v)，找出从顶点u到顶点v的最短路径</li>
</ul>
<h3 id="最少硬币找零问题"><a href="#最少硬币找零问题" class="headerlink" title="最少硬币找零问题"></a>最少硬币找零问题</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额d1…dn及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数， 以及可用的硬币面额d1…dn及其数量，找到所需的最少的硬币个数</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>感觉和斐波那契数列的思想相似。斐波那契数列每个位置的值需要先求其前两项的值。硬币找零也是这个思路。</p>
<p>假如硬币面额是1,3,4，求25的最少硬币找零，这时分三种情况：找一个1元的硬币，然后找24的最少硬币找零；找一个3元的硬币，然后找22的最少硬币找零；找一个4元的硬币，然后找22的最少硬币找零。而24、22、21的最少硬币找零则是重复上面的分析。这样我们就把大问题分解成多个小问题来依次解决。</p>
<p><strong>在实施的过程中，我们把已经求出来的最少硬币找零数缓存起来来方便后续的使用，同时也提高了效率</strong></p>
<p><strong>动态规划实际上就是对可能的情况进行顺序的穷举，然后选取最优解</strong></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划，最少硬币找零问题</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MinCoinCharge</span> (<span class="params">coinsArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> coins = coinsArr;</span><br><span class="line">  <span class="keyword">let</span> cache = [];</span><br><span class="line">  <span class="comment">// 返回包含应找硬币的数组</span></span><br><span class="line">  <span class="keyword">this</span>.makeCharge = <span class="function">(<span class="params">amount</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!amount) &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line">    <span class="keyword">if</span> (cache[amount]) &#123; <span class="keyword">return</span> cache[amount]&#125;</span><br><span class="line">    <span class="keyword">let</span> min = [], newMin, newAmount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> coin = coins[i];</span><br><span class="line">      newAmount = amount - coin;</span><br><span class="line">      <span class="keyword">if</span> (newAmount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        newMin = <span class="keyword">this</span>.makeCharge(newAmount);</span><br><span class="line">        <span class="keyword">if</span> ((newMin.length &lt; min.length <span class="number">-1</span>) || min.length === <span class="number">0</span>) &#123;</span><br><span class="line">          min = [coin].concat(newMin);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[amount] = min;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回最少硬币数和各个硬币的个数</span></span><br><span class="line">  <span class="keyword">this</span>.formatCharge = <span class="function">(<span class="params">amount</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> coins_arr = <span class="keyword">this</span>.makeCharge(amount);</span><br><span class="line">    <span class="keyword">let</span> result = &#123;&#125;;</span><br><span class="line">    coins_arr.forEach(<span class="function"><span class="params">coin</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(result).indexOf(<span class="string">`<span class="subst">$&#123;coin&#125;</span>`</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">        result[coin] = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result[coin]++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: coins_arr.length,</span><br><span class="line">      coins: result,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> minCoinCharge = <span class="keyword">new</span> MinCoinCharge([<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(minCoinCharge.makeCharge(<span class="number">36</span>), minCoinCharge.formatCharge(<span class="number">36</span>));</span><br></pre></td></tr></table></figure>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择(当前最好的解)，从而达到全局的最优(全局最优解)。它不像动态规划那样计算更大的格局。</p>
<p>如下面程序运行，正常最少硬币找零数应该是2，即两张9元硬币。但贪心算法的结果却是5张。很显然并不正确</p>
<p>比起动态规划算法而言，贪心算法更简单、更快。然而，如我们所见，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解</p>
<h3 id="最少硬币找零-贪心算法版"><a href="#最少硬币找零-贪心算法版" class="headerlink" title="最少硬币找零(贪心算法版)"></a>最少硬币找零(贪心算法版)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MinCoin</span>(<span class="params">coinsArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> coins = coinsArr;</span><br><span class="line">  <span class="keyword">this</span>.getCharge = <span class="function">(<span class="params">amount</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> charge = [];</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = coins.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">let</span> coin = coins[i];</span><br><span class="line">      <span class="keyword">while</span> (total + coin &lt;= amount) &#123;</span><br><span class="line">        charge.push(coin);</span><br><span class="line">        total += coin;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> charge;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> minCoin = <span class="keyword">new</span> MinCoin([<span class="number">1</span>,<span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>,<span class="number">25</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(minCoin.getCharge(<span class="number">18</span>));</span><br></pre></td></tr></table></figure>
<h2 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h2><p>我们用大O表示法表示算法的时间复杂度</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 《学习JavaScript数据结构与算法》 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《学习JavaScript数据结构与算法》读书笔记--排序和搜索算法]]></title>
      <url>/2017/10/09/%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换他们。元素向上移动至正确的位置，就好像气泡浮到水面一样，因此得名<br><strong>不推荐该算法，算法复杂度为O(n^2)</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成随机数组</span></span><br><span class="line"><span class="keyword">const</span> getRadomArray = <span class="function">(<span class="params">range, count</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">const</span> getRange = <span class="function"><span class="params">()</span> =&gt;</span> (<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (range[<span class="number">1</span>] - range[<span class="number">0</span>] + <span class="number">1</span>) + range[<span class="number">0</span>]));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    arr.push(getRange());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化数组</span></span><br><span class="line"><span class="keyword">let</span> array = getRadomArray([<span class="number">1</span>, <span class="number">100</span>], count);</span><br><span class="line"><span class="comment">// 交换数组元素</span></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">i, j</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = array[i];</span><br><span class="line">  array[i] = array[j];</span><br><span class="line">  array[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> len = array.length;</span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">      swap(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序算法是一种原址比较排序算法，找出数据结构中的最小值放到第一位，然后找第二小的放到第二位，依此类推<br><strong>不推荐该算法，算法复杂度为O(n^2)</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="keyword">const</span> len = array.length;</span><br><span class="line"><span class="keyword">let</span> minIndex;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">  minIndex = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[j] &lt; array[minIndex]) &#123;</span><br><span class="line">      minIndex = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i !== minIndex) &#123;</span><br><span class="line">    swap(i, minIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序假设左侧已经是个有序数组，然后将右侧每一项依次插入左侧数组的正确位置。由于一个元素的数组本身就是排序的，所以初始状态已经有了<br><strong>排序小型数组时，插入排序比选择排序和冒泡排序效果好</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">const</span> len = array.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> j = i;</span><br><span class="line">  <span class="keyword">const</span> temp = array[i];</span><br><span class="line">  <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">    array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">    j--;</span><br><span class="line">  &#125;</span><br><span class="line">  array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是第一个可以被实际使用的排序算法，其算法复杂度为O(nlogn)。<br>归并排序是一种分治算法，其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直至归并完毕</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [], li = ri = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> ll = left.length, rl = right.length;</span><br><span class="line">  <span class="keyword">while</span> (li &lt; ll &amp;&amp; ri &lt; rl) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[li] &lt; right[ri]) &#123;</span><br><span class="line">      result.push(left[li++]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right[ri++]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (li &lt; ll) &#123;</span><br><span class="line">    result.push(left[li++]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (ri &lt; rl) &#123;</span><br><span class="line">    result.push(right[ri++]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mergeSortRec = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> len = array.length</span><br><span class="line">  <span class="keyword">if</span> (len === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">      left = array.slice(<span class="number">0</span>, mid),</span><br><span class="line">      right = array.slice(mid, len);</span><br><span class="line">  <span class="keyword">return</span> merge(mergeSortRec(left), mergeSortRec(right));</span><br><span class="line">&#125;</span><br><span class="line">array = mergeSortRec(array);</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序也许是最常用的排序算法了。复杂度为O(nlogn)，且它的性能通常比其他的复杂度为O(nlogn)的排序算法要好<br>和归并排序一样，快速排序也使用分治的方法，将原始数组分成较小的数组(但它没有像归并排序一样把他们分隔开)。<br>快速排序先选中一个主元，然后将数组中比主元小的元素移到主元左侧，比主元大的元素移到主元右侧。然后对左右两个数组继续进行相同的操作，直至数组全部排序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="keyword">const</span> quick = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr &#125;</span><br><span class="line">  <span class="keyword">const</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> left = [];</span><br><span class="line">  <span class="keyword">let</span> right = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt;= pivot) &#123;</span><br><span class="line">      left.push(arr[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> quick(left).concat([pivot], quick(right));</span><br><span class="line">&#125;;</span><br><span class="line">array = quick(array);</span><br></pre></td></tr></table></figure>
<h2 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h2><h3 id="顺序-线性搜索"><a href="#顺序-线性搜索" class="headerlink" title="顺序/线性搜索"></a>顺序/线性搜索</h3><p>顾名思义，依次全部遍历，查找我们需要的元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序搜索</span></span><br><span class="line">sequentialSearch = <span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> len = array.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] === item) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p>二分搜索要求数组是已经排序好的</p>
<ul>
<li>选择数组的中间值</li>
<li>如果选中值是搜索值，则执行完毕</li>
<li>如果待搜索的值比选中值要小，对左侧数组重复执行上述操作</li>
<li>如果待搜索的值比选中值要大，对右侧数组重复执行上述操作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索</span></span><br><span class="line">binarySearch = <span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  array = quick(array);</span><br><span class="line">  <span class="keyword">let</span> low = <span class="number">0</span>, high = array.length - <span class="number">1</span>, mid, element;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>);</span><br><span class="line">    element = array[mid];</span><br><span class="line">    <span class="keyword">if</span> (element === item) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element &lt; item) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 《学习JavaScript数据结构与算法》 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《学习JavaScript数据结构与算法》读书笔记--图]]></title>
      <url>/2017/10/09/%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E5%9B%BE/</url>
      <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>图是网络结构的抽象模型。图是一组<strong>由边连接的节点(或顶点)</strong>。<strong>任何二元关系</strong>都可以用图来表示。包括社交网络，例如Facebook、Twitter、Google plus等，还可以用图来表示道路、航班以及通信状态<br><img src="/2017/10/09/《学习JavaScript数据结构与算法》读书笔记--图/图.png" alt="图"></li>
<li>一个图 <code>G=(V,E)</code>由以下元素组成<ul>
<li><code>V</code>: 一组顶点</li>
<li><code>E</code>: 一组边，连接<code>V</code>中的顶点</li>
</ul>
</li>
<li><strong>相邻顶点</strong>：由一条边连接在一起的顶点</li>
<li><strong>度</strong>：一个顶点相邻顶点的<strong>数量</strong></li>
<li><strong>路径</strong>：路径是顶点<code>v1,v2,v3,...,v</code>k的一个连续序列，其中<code>vi</code>和<code>v(i+1)</code>是相邻的</li>
<li><strong>简单路径</strong>：简单路径要求不包含重复的顶点</li>
<li><strong>环</strong>：环也是一个简单路径</li>
<li>如果图中不存在环，则称这个图是<strong>无环的</strong>，如果图中每两个顶点间都存在路径，则该图是<strong>连通的</strong></li>
<li>图可以是无方向的(无向图)或是有方向的(有向图)<br><img src="/2017/10/09/《学习JavaScript数据结构与算法》读书笔记--图/有向图.png" alt="有向图"></li>
<li>如果图中每两个顶点间在双向上都存在路径，则该图是强连通的</li>
<li>图还可以是<strong>未加权的</strong>，或是<strong>加权的</strong><br><img src="/2017/10/09/《学习JavaScript数据结构与算法》读书笔记--图/加权图.png" alt="加权图"></li>
<li>图可以解决计算机科学中的很多问题，比如<ul>
<li>搜索图中的一个特定顶点或搜索一条特定边</li>
<li>寻找图中的一条路径(从一个顶点到另一个顶点)</li>
<li>寻找两个顶点之间的最短路径</li>
<li>环检测</li>
</ul>
</li>
<li>图的表示：从数据结构的角度来说，我们有很多方式来表示图。不存在正确的表达法。图的正确表达法取决于待解决的问题和图的类型<ul>
<li><strong>邻接矩阵</strong>：用一个二维数组表示顶点之间的连接</li>
<li>不是强连通的图(<strong>稀疏图</strong>)如果用邻接矩阵来表示，矩阵中会有很多0，会造成储存空间的浪费</li>
<li>图中的顶点数量可能会变，而二维数组不太灵活<br><img src="/2017/10/09/《学习JavaScript数据结构与算法》读书笔记--图/邻接矩阵.png" alt="邻接矩阵"></li>
<li><strong>邻接表</strong>：邻接表由图中每个顶点的相邻顶点列表组成，我们可以用多种数据结构来表示这种数据结构<br><img src="/2017/10/09/《学习JavaScript数据结构与算法》读书笔记--图/邻接表.png" alt="邻接表"></li>
<li><strong>关联矩阵</strong>：用一个二维数组表示边和顶点的关系<br><img src="/2017/10/09/《学习JavaScript数据结构与算法》读书笔记--图/关联矩阵.png" alt="关联矩阵"></li>
</ul>
</li>
</ol>
<p><img src="/2017/10/09/《学习JavaScript数据结构与算法》读书笔记--图/广度优先搜索.png" alt="广度优先搜索"><br><img src="/2017/10/09/《学习JavaScript数据结构与算法》读书笔记--图/深度优先搜索.png" alt="深度优先搜索"></p>
<h2 id="简单代码实现"><a href="#简单代码实现" class="headerlink" title="简单代码实现"></a>简单代码实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 邻接表表示法</span></span><br><span class="line">  <span class="keyword">let</span> vertices = []; <span class="comment">// 顶点列表</span></span><br><span class="line">  <span class="keyword">let</span> adjLists = <span class="keyword">new</span> Dictionary(); <span class="comment">// 用字典来储存相邻顶点列表</span></span><br><span class="line">  <span class="comment">// white 代表未发现、gray 代表已发现、black 代表已探索</span></span><br><span class="line">  <span class="keyword">const</span> initColor = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> color = [];</span><br><span class="line">    <span class="keyword">const</span> len = vertices.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      color[vertices[i]] = <span class="string">'white'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加一个顶点</span></span><br><span class="line">  <span class="keyword">this</span>.addVertex = <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">    vertices.push(v);</span><br><span class="line">    adjLists.set(v, []);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为已存在的顶点连接一条边</span></span><br><span class="line">  <span class="keyword">this</span>.addEdge = <span class="function">(<span class="params">v, w</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (vertices.indexOf(v) === <span class="number">-1</span> || vertices.indexOf(w) === <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      adjLists.get(v).push(w);</span><br><span class="line">      adjLists.get(w).push(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 以数组的形式初始化顶点列表</span></span><br><span class="line">  <span class="keyword">this</span>.initVertex = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.addVertex(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 以数组的形式初始化相邻顶点列表</span></span><br><span class="line">  <span class="keyword">this</span>.initEdge = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.addEdge(arr[i][<span class="number">0</span>], arr[i][<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取顶点列表的数组形式</span></span><br><span class="line">  <span class="keyword">this</span>.getVertives = <span class="function"><span class="params">()</span> =&gt;</span> vertices</span><br><span class="line">  <span class="comment">// 获取相邻顶点列表</span></span><br><span class="line">  <span class="keyword">this</span>.getAdjLists = <span class="function"><span class="params">()</span> =&gt;</span> adjLists;</span><br><span class="line">  <span class="comment">// 以字符串形式输出图的邻接表形式</span></span><br><span class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> len = vertices.length;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      str += <span class="string">`<span class="subst">$&#123;vertices[i]&#125;</span> --&gt; `</span>;</span><br><span class="line">      <span class="keyword">let</span> neighbors = adjLists.get(vertices[i]);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; neighbors.length; j++) &#123;</span><br><span class="line">        str += <span class="string">`<span class="subst">$&#123;neighbors[j]&#125;</span> `</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      str += <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Breadth-First Search BFS</span></span><br><span class="line">  <span class="comment">// 广度优先搜索</span></span><br><span class="line">  <span class="comment">// 从指定的第一个顶点开始遍历图，先访问其所有的相邻点，先宽后深的访问顶点</span></span><br><span class="line">  <span class="comment">// 通过将顶点存入队列中，最先入队列的顶点先被探索</span></span><br><span class="line">  <span class="keyword">this</span>.bfs = <span class="function">(<span class="params">v, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line">    <span class="keyword">let</span> color = initColor();</span><br><span class="line">    <span class="keyword">let</span> d = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> pred = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class="line">      d[vertices[i]] = <span class="number">0</span>;</span><br><span class="line">      pred[vertices[i]] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.enqueue(v);</span><br><span class="line">    color[v] = <span class="string">'gray'</span>;</span><br><span class="line">    <span class="comment">// 入队列，已发现，变 white</span></span><br><span class="line">    <span class="comment">// 相邻顶点入队列，该点已探索，变 black</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">let</span> u = queue.dequeue();</span><br><span class="line">      <span class="keyword">let</span> neighbors = adjLists.get(u);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color[neighbors[i]] === <span class="string">'white'</span>) &#123;</span><br><span class="line">          queue.enqueue(neighbors[i]);</span><br><span class="line">          color[neighbors[i]] = <span class="string">'gray'</span>;</span><br><span class="line">          d[neighbors[i]] = d[u] + <span class="number">1</span>;</span><br><span class="line">          pred[neighbors[i]] = u;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      color[u] = <span class="string">'black'</span>;</span><br><span class="line">      <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">        callback(u)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      distance: d,</span><br><span class="line">      predecessors: pred,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取v到其他顶点的最短路径</span></span><br><span class="line">  <span class="keyword">this</span>.getShortestPath = <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; distance, predecessors &#125; = <span class="keyword">this</span>.bfs(v);</span><br><span class="line">    <span class="keyword">const</span> len = vertices.length;</span><br><span class="line">    <span class="keyword">const</span> fromVertex = v;</span><br><span class="line">    <span class="keyword">let</span> paths = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> toVertex = vertices[i];</span><br><span class="line">      <span class="keyword">let</span> path = <span class="keyword">new</span> Stack();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> v = toVertex; v !== fromVertex; v = predecessors[v]) &#123;</span><br><span class="line">        path.push(v);</span><br><span class="line">      &#125;</span><br><span class="line">      paths += <span class="string">`<span class="subst">$&#123;fromVertex&#125;</span>`</span>;</span><br><span class="line">      <span class="keyword">while</span> (!path.isEmpty()) &#123;</span><br><span class="line">        paths += <span class="string">` - <span class="subst">$&#123;path.pop()&#125;</span>`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      paths += <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Depth-First Search DFS</span></span><br><span class="line">  <span class="comment">// 深度优先搜索</span></span><br><span class="line">  <span class="comment">// 从指定的第一个顶点开始遍历图，沿着路径直到这条路径最后一个顶点。先深后广度的访问顶点</span></span><br><span class="line">  <span class="comment">// 将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问</span></span><br><span class="line">  <span class="keyword">this</span>.dfs = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> color = initColor();</span><br><span class="line">    <span class="keyword">let</span> d = &#123;&#125;, f = &#123;&#125;, p = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> len = vertices.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      d[vertices[i]] = <span class="number">0</span>;</span><br><span class="line">      f[vertices[i]] = <span class="number">0</span>;</span><br><span class="line">      p[vertices[i]] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dfsVisit = <span class="function">(<span class="params">v, callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'discovered '</span>, v);</span><br><span class="line">      d[v] = ++time;</span><br><span class="line">      color[v] = <span class="string">'gray'</span>;</span><br><span class="line">      <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">        callback(v);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> neighbors = adjLists.get(v);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; neighbors.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color[neighbors[i]] === <span class="string">'white'</span>) &#123;</span><br><span class="line">          p[neighbors[i]] = v;</span><br><span class="line">          dfsVisit(neighbors[i], callback);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      color[v] = <span class="string">'black'</span>;</span><br><span class="line">      f[v] = ++time;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'explored '</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (color[vertices[i]] === <span class="string">'white'</span>) &#123;</span><br><span class="line">        dfsVisit(vertices[i], callback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      discovery: d,</span><br><span class="line">      finished: f,</span><br><span class="line">      predecessors: p,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获得每个顶点发现和完全探索的时间点 eg: A: discovery_time / finished_time</span></span><br><span class="line">  <span class="keyword">this</span>.getDFSTime = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; discovery, finished &#125; = <span class="keyword">this</span>.dfs();</span><br><span class="line">    <span class="keyword">let</span> time_info = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">const</span> len = vertices.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> v = vertices[i];</span><br><span class="line">      time_info += <span class="string">`<span class="subst">$&#123;v&#125;</span>: <span class="subst">$&#123;discovery[v]&#125;</span>/<span class="subst">$&#123;finished[v]&#125;</span>\n`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time_info;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 《学习JavaScript数据结构与算法》 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《学习JavaScript数据结构与算法》读书笔记--树]]></title>
      <url>/2017/10/09/%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E6%A0%91/</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol>
<li>树是一种分层数据的抽象模型，现实中最常见的树的例子是家谱或是公司的组织架构图</li>
<li>一个树结构包括一系列存在父子关系的节点，每个节点都有一个父节点以及零个或多个子节点</li>
<li>根节点：位于树顶部的节点</li>
<li>节点：树中的每个元素<ul>
<li>内部节点：至少有一个子节点的节点</li>
<li>外部/叶节点：没有子元素的节点</li>
</ul>
</li>
<li>子树：由节点和他的后代构成</li>
<li>深度：取决于它的祖先节点的数量，某节点有几个祖先元素深度就是几</li>
<li>高度：取决于所有节点深度的最大值</li>
<li>二叉树：二叉树中的节点最多只能有两个子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法</li>
<li>二叉搜索树 Binary-Search Tree(BST): 二叉搜索树要求左侧节点的值小于等于右侧节点的值</li>
</ol>
<p><img src="/2017/10/09/《学习JavaScript数据结构与算法》读书笔记--树/中序遍历.png" alt="中序遍历"><br><img src="/2017/10/09/《学习JavaScript数据结构与算法》读书笔记--树/先序遍历.png" alt="先序遍历"><br><img src="/2017/10/09/《学习JavaScript数据结构与算法》读书笔记--树/后序遍历.png" alt="后序遍历"></p>
<h2 id="简单代码实现"><a href="#简单代码实现" class="headerlink" title="简单代码实现"></a>简单代码实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> root = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 向树中插入一个新的键</span></span><br><span class="line">  <span class="keyword">const</span> insertNode = <span class="function">(<span class="params">node, newNode</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newNode.key &lt; node.key) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.left = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insertNode(node.left, newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">        node.right = newNode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insertNode(node.right, newNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(key);</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">      root = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      insertNode(root, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在树中查找一个键，返回一个布尔值</span></span><br><span class="line">  <span class="keyword">const</span> searchNode = <span class="function">(<span class="params">node, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key === node.key) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">      <span class="keyword">return</span> searchNode(node.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> searchNode(node.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.search = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    searchNode(root, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历，三种遍历的名称是根据callback调用的位置来命名的</span></span><br><span class="line">  <span class="comment">// 中序遍历：按照从小到大的顺序来遍历节点</span></span><br><span class="line">  <span class="comment">// 中序遍历的一种应用就是对树进行排序操作</span></span><br><span class="line">  <span class="keyword">const</span> inOrderTraverseNode = <span class="function">(<span class="params">node, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      inOrderTraverseNode(node.left, callback);</span><br><span class="line">      callback(node);</span><br><span class="line">      inOrderTraverseNode(node.right, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.inOrderTraverse = <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">    inOrderTraverseNode(root, callback)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先序遍历：先访问节点，再访问其子节点</span></span><br><span class="line">  <span class="comment">// 先序遍历的一种应用是打印一个结构化的文档</span></span><br><span class="line">  <span class="keyword">const</span> preOrderTraverseNode = <span class="function">(<span class="params">node, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      callback(node);</span><br><span class="line">      preOrderTraverseNode(node.left, callback);</span><br><span class="line">      preOrderTraverseNode(node.right, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.preOrderTraverse = <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">    preOrderTraverseNode(root, callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后序遍历：先访问节点的子节点，再访问节点本身</span></span><br><span class="line">  <span class="comment">// 后序遍历的一种应用是计算一个目录和其子目录中所有文件所占用空间的大小</span></span><br><span class="line">  <span class="keyword">const</span> postOrderTraverseNode = <span class="function">(<span class="params">node, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      postOrderTraverseNode(node.left, callback);</span><br><span class="line">      postOrderTraverseNode(node.right, callback);</span><br><span class="line">      callback(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.postOrderTraverse = <span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">    postOrderTraverseNode(root, callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对于二叉搜索树来说，最小值和最大值就是最左侧的节点和最右侧的节点</span></span><br><span class="line">  <span class="comment">// 返回树中的最小值</span></span><br><span class="line">  <span class="keyword">const</span> minNode = <span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> node.key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.min = <span class="function"><span class="params">()</span> =&gt;</span> minNode(root)</span><br><span class="line">  <span class="comment">// 返回树中的最大值</span></span><br><span class="line">  <span class="keyword">const</span> maxNode = <span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="keyword">while</span> (node &amp;&amp; node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> node.key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.max = <span class="function"><span class="params">()</span> =&gt;</span> maxNode(root)</span><br><span class="line">  <span class="comment">// 从树中移除某个键</span></span><br><span class="line">  <span class="comment">// 这个函数有两个作用</span></span><br><span class="line">  <span class="comment">// 1. 递归的寻找需要移除的节点</span></span><br><span class="line">  <span class="comment">// 2. 移除需要移除的节点</span></span><br><span class="line">  <span class="keyword">const</span> removeNode = <span class="function">(<span class="params">node, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.key === key) &#123;</span><br><span class="line">        <span class="comment">// 三种情况</span></span><br><span class="line">        <span class="comment">// 1. 对于叶子节点，直接赋值为null</span></span><br><span class="line">        <span class="comment">// 2. 只有一个左侧或右侧子节点的节点，直接将左/右子节点放到被移除节点的位置</span></span><br><span class="line">        <span class="comment">// 3. 有两个子节点的节点，这种情况比较复杂。先找到右子树的最小值，赋值给被移除节点的位置，然后删除右子树中的最小值</span></span><br><span class="line">        <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.left !== <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> min = minNode(node.right);</span><br><span class="line">          node.key = min;</span><br><span class="line">          node.right = removeNode(node.right, min);</span><br><span class="line">          <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">        node.left = removeNode(node.left, key);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.right = removeNode(node.right, key);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    root = removeNode(root, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>BST存在一个问题，取决于你添加的节点数，树的一条边可能会非常深，这会在某条边上添加、移除和搜索某个节点的时候引起一些性能问题。为了解决这个问题，有一种树叫做<code>阿德尔森-维尔斯树和兰迪斯树(AVL)</code>,VAL树是一种自平衡二叉搜索树。意思是任何一个节点左右两侧子树的高度差最多为1，也就是说这种树会在添加或移除节点的时候尽量试着成为一棵完全树</li>
<li>红黑树:可以进行高效的中序遍历</li>
<li>堆积树:</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 《学习JavaScript数据结构与算法》 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《学习JavaScript数据结构与算法》读书笔记--集合、字典、散列]]></title>
      <url>/2017/10/09/%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%9B%86%E5%90%88%E3%80%81%E5%AD%97%E5%85%B8%E3%80%81%E6%95%A3%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>集合</strong>是由一组无序且唯一的项组成</p>
<h2 id="简单代码实现"><a href="#简单代码实现" class="headerlink" title="简单代码实现"></a>简单代码实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 向集合添加一个新的项</span></span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.has(value)) &#123;</span><br><span class="line">      items[value] = value;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从集合移除一个值</span></span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(value)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> items[value];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 值是否存在于集合中</span></span><br><span class="line">  <span class="keyword">this</span>.has = <span class="function">(<span class="params">value</span>) =&gt;</span> items.hasOwnProperty(value)</span><br><span class="line">  <span class="comment">// 清空集合</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="params">()</span> =&gt;</span> &#123; items = &#123;&#125; &#125;</span><br><span class="line">  <span class="comment">// 返回集合元素个数</span></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Object</span>.keys(items).length</span><br><span class="line">  <span class="comment">// 返回包含集合所有元素的数组,这里要用Object.values，因为keys只能是字符串</span></span><br><span class="line">  <span class="keyword">this</span>.values = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Object</span>.values(items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ES6中的-Set"><a href="#ES6中的-Set" class="headerlink" title="ES6中的 Set"></a>ES6中的 Set</h2><p>ES6中的 Set 结构就是集合的实现</p>
<ol>
<li>基本用法：<ul>
<li>Set 函数可以接受一个数组(或者具有 iterable 接口的其他数据结构)作为参数，用来初始化</li>
<li>向Set中添加值的时候不会发生类型转换</li>
<li>Set内部判断两个值是否不同使用的算法叫做<code>Same-value equality</code>，类似于精确相等运算符(<code>===</code>)，<strong>主要的区别是<code>NaN</code>等于自身</strong>，而<code>===</code>认为<code>NaN</code>不等于自身，另外，两个对象总是不相等的</li>
</ul>
</li>
<li>属性和方法<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的元素总数</li>
<li><code>add(value)</code>: 添加值，返回<code>Set</code>本身</li>
<li><code>delete(value)</code>: 删除某个值，返回一个布尔值表示删除是否成功</li>
<li><code>has(value)</code>: 返回一个布尔值表示该值是否为Set的成员</li>
<li><code>clear()</code>: 清除所有成员，没有返回值</li>
<li><code>keys()</code>: 返回键名的遍历器</li>
<li><code>values()</code>: 返回键值的遍历器</li>
<li><code>entries()</code>: 返回键值对的遍历器</li>
<li><code>forEach()</code>: 使用回调函数遍历每个成员，遍历顺序就是插入顺序。</li>
</ul>
</li>
<li>遍历的应用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line">[...new <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])]</span><br><span class="line"><span class="comment">// 将Set转换为数组使用map和filter</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>))</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter( <span class="function"><span class="params">x</span> =&gt;</span> (x % <span class="number">2</span>) !== <span class="number">0</span>))</span><br><span class="line"><span class="comment">// 实现并集、交集、差集</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)));</span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><strong>字典</strong>也称映射，以[键，值]的形式来储存元素</p>
<h2 id="简单代码实现-1"><a href="#简单代码实现-1" class="headerlink" title="简单代码实现"></a>简单代码实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 添加新元素</span></span><br><span class="line">  <span class="keyword">this</span>.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    items[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用键名移除对应数据</span></span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(key)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> items[key];</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个布尔值表示某个键名是否存在</span></span><br><span class="line">  <span class="keyword">this</span>.has = <span class="function"><span class="params">key</span> =&gt;</span> items.hasOwnProperty(key)</span><br><span class="line">  <span class="comment">// 通过键名返回对应的值</span></span><br><span class="line">  <span class="keyword">this</span>.get = <span class="function"><span class="params">key</span> =&gt;</span> items[key] ? items[key] : <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 清空所有元素</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="params">()</span> =&gt;</span> &#123; items = &#123;&#125; &#125;</span><br><span class="line">  <span class="comment">// 返回字典包含元素的个数</span></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Object</span>.keys(items).length</span><br><span class="line">  <span class="comment">// 返回键名的遍历器</span></span><br><span class="line">  <span class="keyword">this</span>.keys = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Object</span>.keys(items)</span><br><span class="line">  <span class="comment">// 返回键值的遍历器</span></span><br><span class="line">  <span class="keyword">this</span>.values = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Object</span>.values(items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ES6-中的-Map"><a href="#ES6-中的-Map" class="headerlink" title="ES6 中的 Map"></a>ES6 中的 Map</h2><p>ES6 中的 Map 结构就是字典的实现</p>
<ol>
<li>基本用法<ul>
<li>Map 与对象的不同是对象只接受字符串作为键名，而Map的键名可以是任何形式</li>
<li>Map函数接受一个数组(或者任何具有iterable接口，且每个元素都是一个双元素的数组的数据结构)作为参数来初始化</li>
</ul>
</li>
<li>属性和方法<ul>
<li><code>size</code>: 返回Map结构的成员总数</li>
<li><code>set(key, value)</code>: 设置键名<code>key</code>对应的键值为<code>value</code>，返回整个Map结构，如果<code>key</code>值已经存在，则更新</li>
<li><code>get(key)</code>: 返回<code>key</code>对应的键值</li>
<li><code>has(key)</code>: 返回一个布尔值表示该键名是否存在于当前Map对象中</li>
<li><code>delete(key)</code>: 删除某个键，返回布尔值</li>
<li><code>clear()</code>: 清除所有成员，没有返回值</li>
<li><code>keys()</code>: 返回键名的遍历器</li>
<li><code>values()</code>: 返回键值的遍历器</li>
<li><code>entries()</code>: 返回所有成员的遍历器</li>
<li><code>forEach()</code>: 遍历Map的所有成员，遍历顺序就是插入顺序</li>
</ul>
</li>
</ol>
<h1 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>像数组一类的数据结构获取其中的某个值我们需要遍历整个数据结构来找到它。散列表则是通过散列函数直接获得值的位置从而获取到值</p>
<h2 id="简单代码实现-2"><a href="#简单代码实现-2" class="headerlink" title="简单代码实现"></a>简单代码实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loseloseHashCode = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; key.length; i++) &#123;</span><br><span class="line">    hash += key.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hash % <span class="number">37</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> table = [];</span><br><span class="line">  <span class="keyword">this</span>.put = <span class="function">(<span class="params">key, value</span>) =&gt;</span> table[loseloseHashCode(key)] = value;</span><br><span class="line">  <span class="keyword">this</span>.get = <span class="function"><span class="params">key</span> =&gt;</span> table[loseloseHashCode(key)]</span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="params">key</span> =&gt;</span> table[loseloseHashCode(key)] = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><ol>
<li><p>由于不同的键名通过散列函数可能会得到相同的值从而产生碰撞，称为冲突。解决冲突的方法主要有这几种：分离链接、线性探查、双散列法</p>
<ul>
<li><p>分离链接：在散列表的每个位置创建一个链表并将元素储存在里面，但是它在HashTable实例外还需要额外的储存空间</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ValuePair</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.key = key;</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> table = [];</span><br><span class="line">  <span class="keyword">this</span>.put = <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> position = loseloseHashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (table[position] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      table[position] = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    &#125;</span><br><span class="line">    table[position].append(<span class="keyword">new</span> ValuePair(key, value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.get = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> position = loseloseHashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (table[position] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> current = table[position].getHead();</span><br><span class="line">      <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.next.element.key === key) &#123;</span><br><span class="line">          <span class="keyword">return</span> current.next.element.value;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (current.element.key === key) &#123;</span><br><span class="line">        <span class="keyword">return</span> current.element.value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> position = loseloseHashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (table[position] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> current = table[position].getHead();</span><br><span class="line">      <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.next.element.key === key) &#123;</span><br><span class="line">          table[position].remove(current.next.element);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (current.element.key === key) &#123;</span><br><span class="line">        table[position].remove(current.element);</span><br><span class="line">        <span class="comment">// 当没有元素的时候，需要把该位置设为undefined</span></span><br><span class="line">        <span class="keyword">if</span> (table[position].isEmpty()) &#123;</span><br><span class="line">          table[position] = <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线性探查：当想向表中某个位置添加一个新元素的时候，如果索引为index的位置已经被占用了，就尝试index+1的位置，如果依旧被占用，就尝试index+2的位置，依此类推</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ValuePair</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.key = key;</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> table = [];</span><br><span class="line">  <span class="keyword">this</span>.put = <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = loseloseHashCode(key);</span><br><span class="line">    <span class="keyword">while</span> (table[index] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">    table[index] = <span class="keyword">new</span> ValuePair(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.get = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = loseloseHashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (table[index] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span>(table[index] !== <span class="literal">undefined</span> &amp;&amp; table[index].key !== key) &#123;</span><br><span class="line">        index++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (table[index].key === key) &#123;</span><br><span class="line">        <span class="keyword">return</span> table[index].value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.remove = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = loseloseHashCode(key);</span><br><span class="line">    <span class="keyword">if</span> (table[index] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (table[index] !== <span class="literal">undefined</span> &amp;&amp; table[index].key !== key) &#123;</span><br><span class="line">        index++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (table[index].key === key) &#123;</span><br><span class="line">        table[index] = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 《学习JavaScript数据结构与算法》 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《学习JavaScript数据结构与算法》读书笔记--链表]]></title>
      <url>/2017/09/20/%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>链表储存有序的元素集合，每个元素由一个储存本身的节点和一个指向下一个元素的引用组成。<br>有好几种：</p>
<ul>
<li>普通链表：节点包含本身和指向下一个元素的引用</li>
<li>双向链表：节点包含本身和指向下一个元素的引用和指向前一个元素的引用</li>
<li>循环链表：在普通链表的基础上最后一个节点的下一个元素指向第一个节点</li>
<li>双向循环链表：在双向链表的基础上最后一个节点的下一个元素指向第一个节点、第一个节点的前一个元素指向最后一个节点</li>
</ul>
<h2 id="简单代码实现"><a href="#简单代码实现" class="headerlink" title="简单代码实现"></a>简单代码实现</h2><p>普通链表<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 节点</span></span><br><span class="line">  <span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> head = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 顺序添加一个节点</span></span><br><span class="line">  <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">    <span class="keyword">var</span> current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head === <span class="literal">null</span>) &#123;</span><br><span class="line">      head = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current = head;</span><br><span class="line">      <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">        current = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">      current.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    length ++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在指定位置添加一个节点</span></span><br><span class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">      <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">      <span class="keyword">var</span> current;</span><br><span class="line">      <span class="keyword">var</span> previous;</span><br><span class="line">      <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        node.next = head;</span><br><span class="line">        head = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current = head;</span><br><span class="line">        <span class="keyword">while</span> (index++ <span class="xml"><span class="tag">&lt; <span class="attr">position</span>) &#123;</span></span></span><br><span class="line"><span class="xml">          previous = current;</span></span><br><span class="line"><span class="xml">          current = current.next;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">        previous.next = node;</span></span><br><span class="line"><span class="xml">        node.next = current;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      length++;</span></span><br><span class="line"><span class="xml">      return node.element;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    &#125; else &#123;</span></span><br><span class="line"><span class="xml">      return false;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 返回某个元素的位置</span></span><br><span class="line"><span class="xml">  this.indexOf = function(element) &#123;</span></span><br><span class="line"><span class="xml">    var current = head;</span></span><br><span class="line"><span class="xml">    var index = 0;</span></span><br><span class="line"><span class="xml">    while (current) &#123;</span></span><br><span class="line"><span class="xml">      if (current.element === element) &#123;</span></span><br><span class="line"><span class="xml">        return index;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      index++;</span></span><br><span class="line"><span class="xml">      current = current.next;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    return -1;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 删除某个位置的节点</span></span><br><span class="line"><span class="xml">  this.removeAt = function(position) &#123;</span></span><br><span class="line"><span class="xml">    var current = head,</span></span><br><span class="line"><span class="xml">        previous,</span></span><br><span class="line"><span class="xml">        index = 0;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    if (position &gt;= 0 &amp;&amp; position <span class="tag">&lt; <span class="attr">length</span>) &#123;</span></span></span><br><span class="line"><span class="xml">      if (position === 0) &#123;</span></span><br><span class="line"><span class="xml">        head = head.next;</span></span><br><span class="line"><span class="xml">      &#125; else &#123;</span></span><br><span class="line"><span class="xml">        while (index++ <span class="tag">&lt; <span class="attr">position</span>) &#123;</span></span></span><br><span class="line"><span class="xml">          previous = current;</span></span><br><span class="line"><span class="xml">          current = current.next;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">        previous.next = current.next;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      length--;</span></span><br><span class="line"><span class="xml">      return current.element;</span></span><br><span class="line"><span class="xml">    &#125; else &#123;</span></span><br><span class="line"><span class="xml">      return false;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 移除某个元素</span></span><br><span class="line"><span class="xml">  this.remove = function(element) &#123;</span></span><br><span class="line"><span class="xml">    var index = this.indexOf(element);</span></span><br><span class="line"><span class="xml">    return this.removeAt(index);</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 链表是否为空</span></span><br><span class="line"><span class="xml">  this.isEmpty = function() &#123;</span></span><br><span class="line"><span class="xml">    return length === 0 ? true : false;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 链表的长度</span></span><br><span class="line"><span class="xml">  this.size = function() &#123;</span></span><br><span class="line"><span class="xml">    return length;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 返回链表的字符串</span></span><br><span class="line"><span class="xml">  this.toString = function() &#123;</span></span><br><span class="line"><span class="xml">    var current = head;</span></span><br><span class="line"><span class="xml">    var string = '';</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    while (current) &#123;</span></span><br><span class="line"><span class="xml">      string += current.element.toString() + ' --&gt; ';</span></span><br><span class="line"><span class="xml">      current = current.next;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    return string === '' ? '' : string.slice(0, string.length - 5);</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 清空链表</span></span><br><span class="line"><span class="xml">  this.clear = function() &#123;</span></span><br><span class="line"><span class="xml">    head = null;</span></span><br><span class="line"><span class="xml">    length = 0;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 返回head的引用</span></span><br><span class="line"><span class="xml">  this.getHead = function() &#123;</span></span><br><span class="line"><span class="xml">    return head;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>其他三种链表和普通链表的处理方式大体相同</p>
<ol>
<li>双向链表：添加和移除元素的时候需要考虑添加或删除那个元素与前后两个元素的关联关系</li>
<li>循环链表：添加和删除的时候还需要考虑head和最后一个元素的关联</li>
<li>双向循环链表：添加和删除的时候还需要考虑head和最后一个元素的关联</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 《学习JavaScript数据结构与算法》 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[life-game]]></title>
      <url>/2017/09/20/life-game/</url>
      <content type="html"><![CDATA[<h1 id="生命游戏"><a href="#生命游戏" class="headerlink" title="生命游戏"></a>生命游戏</h1><p><a href="https://codearvin.github.io/life-game">预览</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/29102071" target="_blank" rel="external">参考教程</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>生命游戏（Game of Life），或者叫它的全称John Conway’s Game of Life。是英国数学家约翰·康威在1970年代所发明的一种元胞自动机。<br>所谓元胞自动机其实是一种离散的状态机，即无数个独立的格子，每个格子处于某种状态，然后所有格子按照预先设定好的规律进行状态演化。格子们可以是任意维度. 任意形状. 按任意规律排布的。<br>而生命游戏就是最简单的元胞自动机之一——在二维平面上的方格子（细胞），每个细胞有两种状态：死或活，而下一回合的状态完全受它周围8个细胞的状态而定。按照以下三条规则进行演化：</p>
<ol>
<li>活细胞周围的细胞数如果小于2个或多于3个则会死亡；（离群或过度竞争导致死亡）</li>
<li>活细胞周围如果有2或3个细胞可以继续存活；（正常生存）</li>
<li>死细胞（空格）周围如果恰好有3个细胞则会诞生新的活细胞。（繁殖）<br>这三条规则简称B3/S23。如果调整规则对应的细胞数量，还能衍生出其他类型的自动机。</li>
</ol>
</blockquote>
<p>引用自参考教程</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li style="list-style: none"><input type="checkbox" checked> 在网页以单元格颜色变化模拟细胞的进化迭代</li>
<li style="list-style: none"><input type="checkbox" checked> 运行. 单步. 停止</li>
<li style="list-style: none"><input type="checkbox" checked> 生成随机密度的初始化模版</li>
<li style="list-style: none"><input type="checkbox" checked> 调节运行速度</li>
<li style="list-style: none"><input type="checkbox" checked> 状态显示</li>
<li style="list-style: none"><input type="checkbox" checked> 优化绘制过程</li>
<li style="list-style: none"><input type="checkbox" checked> 调节细胞显示尺寸</li>
<li style="list-style: none"><input type="checkbox" checked> 改变细胞颜色</li>
<li style="list-style: none"><input type="checkbox" checked> 鼠标左键绘制，右键擦除，支持拖拽</li>
<li style="list-style: none"><input type="checkbox"> 提供更多的初始化模版</li>
<li style="list-style: none"><input type="checkbox"> 显示更多的数据</li>
<li style="list-style: none"><input type="checkbox"> 可以通过调色板选择细胞颜色</li>
<li style="list-style: none"><input type="checkbox"> 现在的进化规则是B3/S23，再添加一种B36/S23</li>
<li style="list-style: none"><input type="checkbox"> 支持导入、导出RLE格式</li>
<li style="list-style: none"><input type="checkbox"> 支持导出GIF</li>
<li style="list-style: none"><input type="checkbox"> 可以插入由RLE格式生成的图形</li>
<li style="list-style: none"><input type="checkbox"> 适配移动端</li>
</ul>
<h2 id="使用的工具"><a href="#使用的工具" class="headerlink" title="使用的工具"></a>使用的工具</h2><p><a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">create-react-app</a></p>
<p><a href="https://www.npmjs.com/package/gh-pages" target="_blank" rel="external">gh-page</a> 用来发布到Github</p>
<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ol>
<li>通过一个二维数组标识细胞的状态：0为死细胞、1为活细胞</li>
<li>通过判断细胞八个相邻细胞的状态来计算出下一状态的二维数组(注意边界判断)</li>
<li>由于setState是异步操作，所以如果某些操作改变了state的值，我们需要在setState的第二个参数里才能取到更新后的state值</li>
<li>我感觉这个项目不适合在React里面写，React是数据驱动页面的更新，而canvas绘图则是先获取canvas元素再进行操作</li>
<li>绘制的时候判断细胞状态是否发生改变，改变才会进行重绘，提高效率</li>
<li><p>获取鼠标点击位置相对于点击元素的坐标代码，<strong>这里有个bug</strong>就是如果用Mac的触控板对页面进行放大的话(不是缩放)，<code>e.clientX</code>和<code>e.clientY</code>获取的值会不正确，<code>e.clientX</code>获取的值应该是点击位置在浏览器可视区域的坐标。但放大后获取的值和未放大点击对应位置的值是一样的。但而<code>window.scrollX</code>的值是正常的，这就导致了点击对应细胞单元格后发生变化的是另一个单元格。<strong>这个bug目前还没有解决</strong></p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getPageCoord = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> coord = &#123; <span class="attr">X</span>: <span class="number">0</span>, <span class="attr">Y</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">let</span> element = target;</span><br><span class="line">  <span class="keyword">while</span> (element) &#123;</span><br><span class="line">    coord.X += element.offsetLeft;</span><br><span class="line">    coord.Y += element.offsetTop;</span><br><span class="line">    element = element.offsetParent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> coord;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getOffset = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> target = e.target;</span><br><span class="line">  <span class="keyword">let</span> pageCoord = getPageCoord(target);</span><br><span class="line">  <span class="keyword">const</span> eventCoord = &#123;</span><br><span class="line">    X: <span class="built_in">window</span>.pageXOffset + e.clientX,</span><br><span class="line">    Y: <span class="built_in">window</span>.pageYOffset + e.clientY,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'pageCoord'</span>, pageCoord, e.clientX, e.clientY);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    X: eventCoord.X - pageCoord.X,</span><br><span class="line">    Y: eventCoord.Y - pageCoord.Y,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> coordinate = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">   e = e || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    coord_X: e.offsetX ? e.offsetX : getOffset(e).X,</span><br><span class="line">    coord_Y: e.offsetY ? e.offsetY : getOffset(e).Y,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>window.pageXOffset</code>是<code>window.scrollX</code>的别名，为了跨浏览器兼容性，请使用 <code>window.pageXOffset</code> 代替 <code>window.scrollX</code></p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用命令行命令]]></title>
      <url>/2017/05/11/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="一、Heroku"><a href="#一、Heroku" class="headerlink" title="一、Heroku"></a>一、Heroku</h1><h2 id="1-在heroku上部署app"><a href="#1-在heroku上部署app" class="headerlink" title="1. 在heroku上部署app"></a>1. 在heroku上部署app</h2><ul>
<li>对项目文件夹设置git</li>
<li>运行heroku create <appname></appname></li>
<li>把项目推送至heroku远端 git push heroku master</li>
<li>保证项目文件夹内包含以下文件：<ul>
<li><strong>.gitignore</strong> 目前填写 node_modules npm-debug.log</li>
<li><strong>.env</strong></li>
<li><strong>Procfile</strong>  填写项目运行需启动的文件，目前我应该写web: node index.js</li>
<li><strong>README.md</strong><h2 id="2-heroku命令"><a href="#2-heroku命令" class="headerlink" title="2. heroku命令"></a>2. heroku命令</h2></li>
</ul>
</li>
<li><strong>heroku login</strong>： 登陆</li>
<li><strong>heroku create</strong>： 创建app，同时一个git remote（heroku)被创建</li>
<li><strong>heroku create [appname]</strong> 创建名为appname的app，同时一个git remote（heroku）被创建</li>
<li><strong>heroku ps:scale web=1</strong>： 运行app</li>
<li><strong>heroku open</strong>： 在浏览器打开app网址</li>
<li><strong>heroku local</strong>： 本地运行app</li>
<li><strong>heroku logs</strong>： 显示日志</li>
<li><strong>heroku ps:scale web=[num] - -app [appname]</strong>： 运行指定的app</li>
</ul>
<h1 id="二、Git"><a href="#二、Git" class="headerlink" title="二、Git"></a>二、Git</h1><h2 id="1-新建代码库"><a href="#1-新建代码库" class="headerlink" title="1. 新建代码库"></a>1. 新建代码库</h2><ul>
<li><strong>git init</strong>：初始化一个git仓库<h2 id="2-添加-删除文件"><a href="#2-添加-删除文件" class="headerlink" title="2. 添加/删除文件"></a>2. 添加/删除文件</h2></li>
<li><strong>git add [file]</strong>：添加文件至暂存区</li>
<li><strong>git add .</strong>：添加当前目录所有文件至暂存区<h2 id="3-代码提交"><a href="#3-代码提交" class="headerlink" title="3. 代码提交"></a>3. 代码提交</h2></li>
<li><strong>git commit -m [message]</strong>：提交暂存区到仓库区<h2 id="4-分支"><a href="#4-分支" class="headerlink" title="4. 分支"></a>4. 分支</h2></li>
<li><strong>git branch</strong>：列出所有本地分支</li>
<li><strong>git branch -r</strong>：列出所有远程分支</li>
<li><strong>git branch -a</strong>：列出所有本地和远程分支</li>
<li><strong>git branch [branch-name]</strong>：新建分支但留在当前分支</li>
<li><strong>git checkout -b [branch-name]</strong>：新建分支并切换到该分支</li>
<li><strong>git merge [branch]</strong>：合并指定分支到当前分支</li>
<li><strong>git branch -d [branch-name]</strong>：删除分支</li>
<li><strong>git branch -dr [remote/branch]</strong>：删除远程分支</li>
<li><strong>git branch -vv</strong>: 查看本地分支以及其关联的远程分支</li>
<li><strong>git branch –set-upstream-to <local-branch> <remote-branch></remote-branch></local-branch></strong>: 为某一本地分支设置其远程分支关联<h2 id="5-查看信息"><a href="#5-查看信息" class="headerlink" title="5. 查看信息"></a>5. 查看信息</h2></li>
<li><strong>git status</strong>：显示有变更的文件</li>
<li><strong>git log</strong>：显示当前分支的版本历史</li>
<li><strong>git diff</strong>：显示暂存区和工作区的区别</li>
<li><strong>git log –pretty=oneline \<filename\></filename\></strong>: 查看一个文件的提交记录</li>
<li><strong>git show \<hashcode\> \<filename\></filename\></hashcode\></strong>: 查看某个文件在某次提交的修改</li>
<li><strong>git diff \<hashcode-before-right\> \<hashcode\> \<filename\></filename\></hashcode\></hashcode-before-right\></strong>: 查看某个文件两个版本之间的差异<h2 id="6-远程同步"><a href="#6-远程同步" class="headerlink" title="6. 远程同步"></a>6. 远程同步</h2></li>
<li><strong>git remote -v</strong>：显示所有远程仓库</li>
<li><strong>git remote add [name] [url]</strong>：新建一个远程仓库并命名</li>
<li><strong>git push [remote] [branch]</strong>：上传本地分支至远程仓库</li>
<li><strong>git push [remote] [local_branch]:[remote_branch]</strong>：上传本地分支至远程仓库分支<h2 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h2></li>
<li><strong>Linux下为git设置SSH</strong>：<br>1、本地生成密匙对：一般密匙储存在<code>~/.ssh</code>目录下，如果没有用命令<code>ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</code><br>2、添加公钥到github账户，在 github SSH Keys 页面添加，添加你的公钥内容。用命令<code>ssh -T git@gituhb.com</code>来验证这个key是否工作正常，正常则返回<code>Hi username! You&#39;ve successfully authenticated, but GitHub does not # provide shell access.</code><br>3、修改本地ssh remote url 为git协议，用<code>git remote set-url &lt;remote_name&gt; &lt;url&gt;</code>来切换协议。<br>4、OK</li>
<li><strong>git checkout .</strong>: 撤销暂存区所有未提交的更改至工作区</li>
</ul>
<h1 id="三、-npm"><a href="#三、-npm" class="headerlink" title="三、 npm"></a>三、 npm</h1><ul>
<li><strong>npm list -g –depth 0</strong>：列出全局环境下安装的包</li>
<li><strong>npm subtree push –prefix=dist github gh-pages</strong>：把仓库子文件dist推送至远端仓库github的gh-pages分支</li>
<li><strong>yeoman命令</strong><ul>
<li><code>npm install -g yo</code>：yeoman项目结构生成器</li>
<li><code>npm install -g generator-react-webpack</code>：安装项目生成器</li>
<li>启动项目时候访问<code>localhost:8000/webpack-dev-server</code>体验更好，会有提示</li>
</ul>
</li>
<li><code>npm ls -g --depth=1 2&gt;/dev/null | grep generator-</code>：查看本地generator版本，在window中运行没有出结果，我运行的是<code>npm ls -g --depth=0 | grep generator-</code><ul>
<li><code>npm ls -g --depth=1</code>：列出全局npm包，限制树状结构最多向下展示一层</li>
<li><code>2&gt;/dev/null</code>：在bash中，<code>&gt;</code>表示重定向，1表示标准输出，2表示标准错误，<code>/dev/null</code>表示空设备文件。如果前面命令出现错误，将错误重定向到空设备文件，即不显示在控制台上</li>
<li><code>|</code>：表示通道，用来将上一个命令的输出内容作为下个命令的输入内容</li>
<li><code>grep generator-</code>：在前面的输出中检索generator-开头的内容</li>
</ul>
</li>
</ul>
<h1 id="四、-命令行"><a href="#四、-命令行" class="headerlink" title="四、 命令行"></a>四、 命令行</h1><ul>
<li><strong>msiexec /i {the msi path}</strong>：以管理员身份运行msi文件</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 命令行 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Atom记录]]></title>
      <url>/2017/05/08/Atom%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h1 id="1-快捷键"><a href="#1-快捷键" class="headerlink" title="1. 快捷键"></a>1. 快捷键</h1><ul>
<li><strong>F11</strong>：全屏</li>
<li><strong>Ctrl + Shift + ‘+’/‘-‘</strong>：增大/减小字体</li>
<li><strong>Ctrl + |</strong>：隐藏/展示目录树</li>
<li><strong>Ctrl + Shift + P</strong>：全局搜索面板</li>
<li><strong>Ctrl + L</strong>：选定一行</li>
<li><strong>Ctrl + D</strong>：匹配选定下一个</li>
<li><strong>Alt + F3</strong>：匹配选定所有</li>
<li><strong>Ctrl + P</strong>：查询文件</li>
<li><strong>Ctrl + Del</strong>：删除光标至词尾处</li>
<li><strong>Ctrl + /</strong>：启用注释</li>
<li><strong>Ctrl + [ / ]</strong>：左/右缩进</li>
<li><strong>Ctrl + up/down</strong>：行向上/向下移动</li>
<li><strong>Ctrl + Enter</strong>：光标之下增加一行</li>
<li><strong>Ctrl + Shift + Enter</strong>：光标之上增加一行</li>
<li><strong>Ctrl + Tab</strong>：切换编辑的标签页</li>
<li><strong>Ctrl + ,</strong>：打开settings界面</li>
</ul>
<h1 id="2-插件"><a href="#2-插件" class="headerlink" title="2. 插件"></a>2. 插件</h1><ul>
<li><strong>minimap</strong>：快速查看当前代码在整体代码的位置</li>
<li><strong>emmet</strong>：快捷输入html</li>
<li><strong>file-icons</strong>：更好看的文件图标</li>
<li><strong>linter-jshint</strong>：检测js中不规范的地方</li>
<li><strong>color-pick</strong>：颜色选取器，快捷键：Ctrl + Alt + C</li>
<li><strong>pigments</strong>：在CSS代码显示颜色</li>
<li><strong>activate-power-mode</strong>：在写的时候显示震动效果</li>
<li><strong>atom-beautiful</strong>：让代码排版更友好，好看</li>
<li><strong>markdown-preview-enhanced</strong>：现在改用这个功能强大的插件了，下面三个已经卸载</li>
<li><strong>markdown-preview-plus</strong>：预览markdown文件。快捷键：Ctrl + Shift + M</li>
<li><strong>markdown-scroll-sync</strong>：预览实时滚动</li>
<li><strong>markdown-toc</strong>：生成markdown目录，Ctrl + Shift + P，输入toc，回车</li>
<li><strong>language-markdown</strong>：MD高亮支持</li>
<li><strong>simplified-chinese-menu</strong>：ATOM中文菜单</li>
<li><strong>autocomplete-paths</strong>：自动匹配路径</li>
<li><strong>aotucomplete-plus</strong>：自动匹配输入</li>
<li><strong>atom-html-preview</strong>：预览html。快捷键：Ctrl + Shift + H</li>
<li><strong>git-plus</strong>：在atom使用git命令行命令。Ctrl + Shift + H</li>
<li><strong>git-control</strong>：git图形化界面</li>
<li><strong>git-log</strong>：图形化显示提交记录</li>
<li><strong>tree-view-git-status</strong>：在目录显示git状态</li>
<li><strong>code-peek</strong>：快速提示和编辑其他文件中的函数功能，不需要单独打开那个文件了。快捷键：Ctrl-Alt-E</li>
<li><strong>sync-settings</strong>：把你的atom配置上传至github gist可以随时更新和应用在本地<ul>
<li><strong>backup</strong>：备份当前配置/更新当前配置至gist</li>
<li><strong>restore</strong>：还原配置</li>
<li><strong>view-backup</strong>：查看线上备份</li>
<li><strong>check-backup</strong>：检查最新的备份</li>
</ul>
</li>
<li><strong>autoclose-html</strong>：自动补全html标签</li>
<li><strong>react</strong>：在react里也可以自动补全html标签了</li>
<li><strong>highlight-selected</strong>: 双击代码突出所有相同代码</li>
<li><strong>minimap-highlight-selected</strong>: 同时在minimap上显示突出，是对highlight-selected的拓展，用这个也需要安装highlight-selected。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Atom </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu折腾记录]]></title>
      <url>/2017/05/05/ubuntu%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="Linux-window双系统"><a href="#Linux-window双系统" class="headerlink" title="Linux,window双系统"></a>Linux,window双系统</h2><p><a href="http://www.jb51.net/os/windows/298507.html" target="_blank" rel="external">教程</a></p>
<h2 id="软件安装不了问题"><a href="#软件安装不了问题" class="headerlink" title="软件安装不了问题"></a>软件安装不了问题</h2><p>缺少软件，需安装GDebi。安装命令<code>sudo apt-get update</code> <code>sudo apt-get install gdebi</code></p>
<h2 id="nodejs安装"><a href="#nodejs安装" class="headerlink" title="nodejs安装"></a>nodejs安装</h2><p>在官网Download页面选择Installing Node.js via package manager。ubuntu的命令是<code>curl -sL https://deb.nodesource.com/setup_7.x | sudo -E bash -</code> <code>sudo apt-get install -y nodejs</code></p>
<h2 id="任务管理器"><a href="#任务管理器" class="headerlink" title="任务管理器"></a>任务管理器</h2><p>按window键搜索system monitor显示图形界面的任务管理器</p>
<h2 id="标题栏显示网速"><a href="#标题栏显示网速" class="headerlink" title="标题栏显示网速"></a>标题栏显示网速</h2><p>安装软件indicator-sysmonitor,可以命令行启动，也可以搜索出来启动</p>
<h2 id="开热点"><a href="#开热点" class="headerlink" title="开热点"></a>开热点</h2><p><a href="http://www.linuxdiyf.com/linux/24898.html" target="_blank" rel="external">教程</a><br>网络连接的文件位置：<code>/etc/NetworkManager/system-connections</code></p>
<h2 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h2><p>蓝灯直接官网安装<br><a href="http://blog.csdn.net/scythe666/article/details/52015213" target="_blank" rel="external">shadowsocks安装教程</a></p>
<h2 id="大坑"><a href="#大坑" class="headerlink" title="大坑"></a>大坑</h2><p>把ibus卸载后系统桌面也没了，网上找到了修复方法但发现电脑始终连不上网。最后只好重装，先在window下删除ubuntu对应的分区，重启后悲剧了。才想起来现在双系统ubuntu好像是主系统，删除后开机引导出错了。<strong>不能直接删除ubuntu的分区</strong>。用U盘PE修复了引导记录，重新安装了一遍ubuntu。重新配置了开发环境。系统换成英文的，在字符界面就不会出现乱码了，但ibus中文输入法按照教程安装方法总是不成功，很难受。最后下载了搜狗输入法，很方便，还有繁简体转换。linux安装软件有的很麻烦，卸载更是要注意，一些关键的依赖是不能直接卸载的，当时一个回车的时间需要大半天的时间来修复，这还是我新装的ubuntu，没有很多东西的情况下。</p>
<h2 id="shadowsocks-amp-proxychains-实现终端代理"><a href="#shadowsocks-amp-proxychains-实现终端代理" class="headerlink" title="shadowsocks &amp; proxychains 实现终端代理"></a>shadowsocks &amp; proxychains 实现终端代理</h2><p>1、安装proxychains: <code>sudo apt-get install proxychains</code><br>2、启动shadowsocks<br>3、编辑<code>/etc/proxychains.conf</code>，在最后的proxylist里加入<code>socks5 127.0.0.1 1080</code><br>4、编辑<code>usr/bin/proxychains</code>修改里面的<code>LD_PRELOAD</code>的值为系统中<code>libproxychains.so.3</code>的位置<br>5、在运行的程序前加上proxychains就可以了。<strong>注意</strong>：proxychains支持的是socks，http, https协议.它们以tcp或者udp协议为基础, ping命令用的是 ICMP 协议， proxychains 不支持。(原来是这样。。。)</p>
<h2 id="安装翻译软件"><a href="#安装翻译软件" class="headerlink" title="安装翻译软件"></a>安装翻译软件</h2><p>先尝试的是<code>translate-shell</code>这个命令行工具，但连接需要翻墙，这时我才知道shadowsocks只能浏览器进行翻墙，配合switchyomega可以实现浏览器端可选择的使用socks代理。但终端就不行了。我又想起来lantern不是vpn吗，但查了一下说是lantern用的是pac(这个是啥)，不嫩进行终端翻墙。最后找到了一个方案是shadowsocks和proxychains进行终端代理，方法在上面，这回可以翻墙但translateshell还是不好用，不知道是我这边的原因还是那边的问题。。。</p>
<p>于是下载了有道词典，但它没有提供快捷键配置项，用起来会很不方便。打开系统设置进行快捷键设置。先要知道有道词典的启动命令。用<code>compgen -c | grep youdao</code>找到命令，进行配置就可以了(但我感觉用了快捷键打开会有延迟，还是命令行打开最快)</p>
<h2 id="在系统加入自己写的shell"><a href="#在系统加入自己写的shell" class="headerlink" title="在系统加入自己写的shell"></a>在系统加入自己写的shell</h2><p>写了一个shell脚本，命令如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">location=~/Documents/attendance.txt</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"need params"</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$1</span> = <span class="string">"--show"</span> ] || [ <span class="variable">$1</span> = <span class="string">"-s"</span> ];<span class="keyword">then</span></span><br><span class="line">more <span class="variable">$location</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$1</span> = <span class="string">"--delete"</span> ] || [ <span class="variable">$1</span> = <span class="string">"-d"</span> ];<span class="keyword">then</span></span><br><span class="line">sed -i <span class="string">"/<span class="variable">$2</span>/d"</span> <span class="variable">$location</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"DELETED"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$(date +%Y/%m/%d)</span> <span class="variable">$(env LC_TIME=en_US.UTF-8 date +%A)</span> <span class="variable">$@</span>"</span> &gt;&gt; <span class="variable">$location</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"SUCCESS"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"FAIL"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<p>几个重要的点：<br>1、shell文件全局永久可用: 把shell文件所在目录加入PATH变量并加入到<code>.bashrc</code>中。<code>echo &quot;PATH=$PATH:/home/codearvin/myshell&quot; &gt;&gt; .bashrc</code><br>2、为命令设置一个简短的别名:</p>
<ul>
<li><code>alias</code>显示所有可用别名。</li>
<li><code>alias ad=attendance.sh</code>只能短时间生效。</li>
<li>查看家目录下的<code>.bashrc</code>文件，里面有对别名的定义，在家目录下创建<code>.bash_aliases</code>文件并在里面写入别名格式，就会永久生效了。<br>3、有个坑: <code>cat test | grep -v somevalue &gt; test</code>这样test文件就变为空了。属于线程干扰的问题？管道几侧的程序是同时运行的<br>4、我的终端语言是中文，但我想date显示的全是英文，用下面这个命令: <code>env LC_TIME=en_US.UTF-8 date</code>就可以了</li>
</ul>
<h2 id="哈哈-thefuck？"><a href="#哈哈-thefuck？" class="headerlink" title="哈哈 thefuck？"></a>哈哈 thefuck？</h2><p>这个工具好玩，可以自动纠正前一个命令的拼写错误<br>安装:</p>
<ul>
<li><code>sudo apt update</code></li>
<li><code>sudo apt install python3-dev python3-pip</code></li>
<li><code>pip3 install --user thefuck</code></li>
<li>创建一个别名 <code>vim ~/.bashrc</code></li>
<li>在文件尾加入一行： <code>eval &quot;$(thefuck --alias fuck)&quot;</code></li>
<li>使生效 <code>source ~/.bashrc</code></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS知识点记录]]></title>
      <url>/2017/04/29/JS%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p><code>parseInt(string, radix)</code>: 将string代表的数转换成10进制数，返回值类型为number</p>
<ul>
<li><code>string</code>: 要被解析的值，如果不是字符串，则将其转换成字符串，字符串开头的空白会被忽略</li>
<li><code>radix</code>: 2-36之间的整数值，表明string代表的数的基数。</li>
</ul>
<p><code>Number.toString(radix)</code>: 返回数的指定基数的字符串表示，默认radix为10</p>
<p>我的理解:</p>
<ul>
<li>parseInt是把字符串转换成数值表示，他的radix用来指定string对应的数的基数，转换后返回的数基数是10。也就是<strong>返回一个字符串的10进制数值表示</strong>。例如<code>parseInt(&#39;1100100&#39;,2)</code>返回<code>100</code></li>
<li>Number.toString是把数值转换成字符表示，radix用来指定转换后的字符对应的数的基数。也就是<strong>返回一个数的radix基数的字符表示</strong>。例如<code>var num = 100; num.toString(2)</code>返回<code>&#39;1100100&#39;</code></li>
</ul>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><img src="/2017/04/29/JS知识点记录/prototype.jpg" alt=""><br>结合图来理解，一点一点的看。<a href="http://www.cnblogs.com/smoothLily/p/4745856.html" target="_blank" rel="external">参考资料</a></p>
<p>1、在JS里，万物皆对象(typeof null === ‘object’是个bug，其他像string、number类型也能用方法，应该是在定义后，编译器会自动用String、Number函数将其包装起来。例如<code>var x = &#39;hello&#39;; x.__proto__ === String.prototype //true</code>)。<strong>对象都拥有属性<code>__proto__</code></strong>，称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型。如图中f1、f2、o1、o2是由构造函数生成的，他们的<code>__proto__</code>属性指向其构造函数的prototype属性。原型对象也是对象，他的<code>__proto__</code>属性指向Object.prototype。</p>
<p>2、函数也是对象，但它除了拥有<code>__proto__</code>属性外还拥有自己的特有属性prototype，称为原型属性。这个属性指向一个对象(突然发现<code>typeof Function.prototype === true</code>，这就很纠结了，这个问题等待解决中。<strong>update at 2017/09/22</strong>)，称为原型对象，<strong>原型对象有一个属性constructor指向原构造函数</strong>。函数也是对象，Foo的构造函数是Function，所以Foo.<code>__proto__</code> === Function.prototype。还有如Object.<code>__proto__</code> === Function.prototype、比较特殊的有Function.<code>__proto__</code> = Function.prototype</p>
<p>3、Object.<code>__proto__</code> === null</p>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux学习记录--命令练习]]></title>
      <url>/2017/04/19/Linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95--%E5%91%BD%E4%BB%A4%E7%BB%83%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p>1、列出目录下指定的目录: <code>ls -d 目录名称</code><br>2、思考: 在一个目录下删除这个目录然后使用<code>pwd</code>这个命令会打印出什么。仍然会打印出当前所在目录，虽然已经被删除了<br>3、<strong>mkdir</strong>:</p>
<ul>
<li><code>mkdir -m 777 zhou</code>: 创建权限为777的目录</li>
<li><code>mkdir -vp shiyanlou/{lib/,bin/,doc/{info,product}}</code>: 创建多个目录(<strong>只能创建目录，即使加上后缀名也是目录。linux中应该是不以后缀名区分文件类型的</strong>)并显示信息。安装<code>tree</code>可以以树状结构显示某个目录</li>
</ul>
<p>4、<code>myrm(){D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D; mv &quot;$@&quot; $D &amp;&amp; echo &quot;moved to $D ok&quot; || &quot;moved to $D fail&quot;}</code>: 将一个文件(需要以存在)移动到/tmp/下以当前时间命名的文件夹下。<code>$@</code>表示传入脚本的参数。<strong>注意</strong>linux命令行中<code>&#39;</code>包括的为字符串，写的是什么就是什么。而<code>&quot;</code>包括的里面如果有变量什么的会替换成变量的值，和不用<code>&quot;</code>包括是一样的。</p>
<p>5、将<code>time</code>命令的执行结果保存到文件中，可以使用如下命令<code>{ time date; } 2&gt;1.txt</code>或<code>(time date) 2&gt;2.txt</code>。大括号两边必须有空格并且命令以分号结束。还有time命令的输出信息是打印在标准错误输出上的。</p>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux学习记录--基本操作]]></title>
      <url>/2017/04/09/Linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95--%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="常用通配符"><a href="#常用通配符" class="headerlink" title="常用通配符"></a>常用通配符</h2><p><code>*</code>: 匹配0或多个字符<br><code>?</code>: 匹配任意一个字符<br><code>[list]</code>: 匹配list中的任意单一字符<br><code>[!list]</code>: 匹配除了list中的单一字符意外的字符<br><code>[c1-c2]</code>: 匹配c1-c2中的任意单一字符<br><code>{string1,string2,...}</code>: 匹配string1或string2(或更多)其一字符<br><code>{c1..c2}</code>: 匹配c1-c2全部字符</p>
<h2 id="用户及文件权限管理"><a href="#用户及文件权限管理" class="headerlink" title="用户及文件权限管理"></a>用户及文件权限管理</h2><p><strong>查看用户</strong>: <code>who am i</code> OR <code>who mom likes</code><br><strong>切换用户</strong>:</p>
<ul>
<li><code>su &lt;user&gt;</code>,</li>
<li><code>su - &lt;user&gt;</code>同时环境变量也会改变成目标用户的环境变量<br><strong>新建用户</strong>: <code>sudo adduser &lt;user&gt;</code><br><strong>查看用户所属的用户组</strong>:</li>
<li><code>groups &lt;user&gt;</code></li>
<li>查看<code>/etc/group</code>文件</li>
</ul>
<p><strong>将用户加入sudo用户组</strong>: <code>sudo usermod -G sudo &lt;user&gt;</code><br><strong>删除用户</strong>: <code>sudo deluser &lt;user&gt; --remove-home</code></p>
<p><strong>文件权限</strong>:<br><img src="/2017/04/09/Linux学习记录--基本操作/quanxian.png" alt=""><br><img src="/2017/04/09/Linux学习记录--基本操作/quanxian1.png" alt=""><br><strong>注意</strong>: 一个目录必须同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才可以在其中创建其他文件，这是因为目录文件实际保存的是该目录里面的文件的列表等信息</p>
<p><strong>更改文件所有者</strong>: <code>sudo chown &lt;user&gt; &lt;file&gt;</code></p>
<p><strong>修改文件权限</strong>:</p>
<ul>
<li><p><strong>二进制数字表示</strong></p>
<ul>
<li><img src="/2017/04/09/Linux学习记录--基本操作/number.png" alt=""></li>
<li>eg: <code>chomd 700 iphone6</code> 权限修改为只有自己可以读写执行</li>
</ul>
</li>
<li><p><strong>加减赋值操作</strong></p>
<ul>
<li><code>g</code> <code>o</code> <code>u</code>分别表示group、others和user，<code>+</code> <code>-</code>分别表示增加或减去相应的权限</li>
<li>eg: <code>chmod go-rw iphone6</code></li>
</ul>
</li>
</ul>
<p><strong><code>adduser</code>和<code>useradd</code>的区别</strong>: <code>useradd</code>只创建用户，创建完用<code>passwd &lt;user&gt;</code>设置用户，而<code>adduser</code>会创建用户并同时设置其他相关参数。其实<code>useradd</code> <code>userdel</code>更像一种命令，执行完就返回。而<code>adduser</code> <code>deluser</code>更像一种程序，需要你输入确定一系列操作</p>
<h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><p><strong>新建一个空白文件</strong>: <code>touch &lt;file&gt;</code><br><strong>新建一个目录</strong>:</p>
<ul>
<li><code>mkdir &lt;dir&gt;</code></li>
<li><code>mkdir -p /parent/son/grandson</code>加上<code>-p</code>参数同时创建父目录</li>
<li><strong>参数</strong>:<ul>
<li><code>-m</code>(–mode): 设定权限&lt;模式&gt;</li>
<li><code>-p</code>(–parents): 设定一系列目录</li>
<li><code>-v</code>(–verbose): 每次创建新目录都显示信息</li>
</ul>
</li>
</ul>
<p><strong>复制文件</strong>:</p>
<ul>
<li><code>cp &lt;file&gt; &lt;dir&gt;</code></li>
<li><code>cp -r &lt;dir&gt; &lt;dir&gt;</code> 加上<code>-r</code>或<code>-R</code>表示递归复制，需要在复制目录的时候加上</li>
</ul>
<p><strong>删除文件</strong>:</p>
<ul>
<li><code>rm &lt;file&gt;</code></li>
<li>有时想删除一些为只读权限的文件，直接用上面的命令会有提示，这时可以用<code>rm -f &lt;file&gt;</code>来忽略这些提示</li>
<li>删除目录，要加上<code>-r</code>或<code>-R</code>参数</li>
<li><strong>参数</strong>:<ul>
<li><code>-f</code>(–force): 忽略不存在的文件，从不给出提示</li>
<li><code>-i</code>(–interactive): 进行交互式删除</li>
<li><code>-r</code>(–recursive): 指示rm将参数中列出的全部目录和子目录递归的删除</li>
<li><code>-v</code>(–verbose): 详细显示进行的步骤<br><strong>移动文件与重命名</strong>:</li>
</ul>
</li>
<li>移动: <code>mv &lt;file&gt; &lt;dir&gt;</code></li>
<li>重命名: <code>mv &lt;old&gt; &lt;new&gt;</code></li>
<li>批量重命名:<ul>
<li><code>touch file{1..5}.txt</code></li>
<li><code>rename &#39;s/\.txt/\.c/&#39; *.txt</code></li>
<li><code>rename &#39;y/a-z/A-Z/&#39; *.c</code></li>
</ul>
</li>
</ul>
<p><strong>查看文件</strong>:</p>
<ul>
<li><code>cat &lt;file&gt;</code>: 正序显示，加上<code>-n</code>显示行号</li>
<li><code>tac &lt;file&gt;</code>: 倒序显示</li>
<li><code>nl</code>: 添加行号并显示，比<code>cat -n</code>更专业<ul>
<li><code>-b</code><ul>
<li><code>-b a</code>: 显示全部行号</li>
<li><code>-b t</code>:只显示非空格行的行号</li>
</ul>
</li>
<li><code>-n</code><ul>
<li><code>-n ln</code>: <strong>行号字段</strong>左侧显示行号</li>
<li><code>-n rn</code>: <strong>行号字段</strong>行号字段侧显示行号且不加0</li>
<li><code>-n rz</code>: <strong>行号字段</strong>侧显示，且加0</li>
</ul>
</li>
<li><code>-w</code>: 行号字段占用的位数，默认为6</li>
</ul>
</li>
<li><code>more &lt;file&gt;</code>: <code>enter</code>键向下滚动一行，<code>space</code>键向下滚动一屏，<code>h</code>显示帮助，<code>q</code>退出</li>
<li><code>less &lt;file&gt;</code>:</li>
<li><code>head &lt;file&gt;</code>: 查看文件头几行，默认为10，加上<code>-n</code>参数指定查看几行</li>
<li><code>tail &lt;file&gt;</code>: 查看文件末尾几行，默认为10；加上<code>-n</code>参数指定查看几行；<code>-f</code>可以不停的读取文件内容并输出，达到实时监控的目的</li>
</ul>
<p><strong>查看文件类型</strong>: <code>file &lt;file&gt;</code></p>
<p><strong>编辑文件</strong>: <code>vim &lt;file&gt;</code></p>
<p><strong>比较文件的不同</strong>: <code>vimdiff &lt;file1&gt; &lt;file2&gt; ...</code></p>
<h2 id="环境变量与文件查找"><a href="#环境变量与文件查找" class="headerlink" title="环境变量与文件查找"></a>环境变量与文件查找</h2><p><strong>声明变量</strong>: <code>declare tmp</code>: 也可以不用declare声明<br><strong>环境变量</strong>:<br>  <code>set</code>: 显示当前shell所有变量，包括其内建变量，用户自定义变量以及导出的环境变量<br>  <code>env</code>: 显示当前用户相关的环境变量<br>  <code>export</code>: 显示从shell中导出成环境变量的变量，也可以通过它将自定义变量导出为环境变量</p>
<p>我们在当前shell声明一个变量例如<code>tmp=helloworld</code></p>
<ul>
<li>目前只能在当前shell环境使用，切换到别的shell环境无法使用，这时使用<code>export tmp</code>导出tmp为环境变量就可以在不同的shell环境下使用了</li>
<li>但当我们关机或者关闭当前shell后环境变量就没有了。按变量的生存周期划分，linux变量分为永久的(需要修改配置文件，永久生效)、临时的(export即可，关闭shell时失效)。有两个重要文件<code>/etc/bashrc</code>、<code>/etc/profile</code>分别存放shell变量和环境变量，每个用户目录下也有一个隐藏文件<code>.profile</code>这个存放的是当前用户的环境变量，而<code>/etc/profile</code>存放的是所有用户的，所以如果想添加一个永久生效的环境变量，只需把他加入<code>/etc/profile</code>即可</li>
</ul>
<p>我们在shell中输入一个命名，shell会按照PATH储存的路径依次去寻找可执行文件，有同名的执行先找到的。</p>
<p><strong>为文件添加可执行权限</strong>: <code>chmod 755 hello_shell.sh</code><br><strong>gcc生成可执行文件</strong>: <code>gcc -o hello_shell hello_shell.c</code><br>我们自己写的可执行文件只能在其所在的目录执行，或者指定其目录进行执行，很不方便。我们可以<code>PATH=$PATH:/yourDir</code>来把可执行文件的目录添加到PATH中。但我们关掉终端就会失效。每个用户的home目录中有一个配置文件，shell每次启动时候都会默认执行它来初始化环境等操作。zsh的为<code>zshrc</code>，bash的为<code>bashrc</code>。他们在<code>etc</code>下也还有一个或多个的全局的配置文件，但我们一般只修改用户目录下的配置文件。<code>echo &quot;PATH=$PATH:/home/shiyanlou/mybin&quot; &gt;&gt; .zshrc</code>这样你写的可执行文件也可以随时使用了</p>
<p><strong>修改和删除已有变量</strong>:<br><code>${变量名#匹配子串}</code>: 从头向后开始匹配，删除符合匹配字串的最短数据<br><code>${变量名##匹配子串}</code>: 从头向后开始匹配，删除符合匹配字串的最长数据<br><code>${变量名%匹配子串}</code>: 从尾向前开始匹配，删除符合匹配字串的最短数据<br><code>${变量名%%匹配子串}</code>: 从尾向前开始匹配，删除符合匹配字串的最长数据<br><code>${变量名/旧的字串/新的字串}</code>: 将符合要求的第一个字串替换为新的字串<br><code>${变量名//旧的字串/新的字串}</code>: 将符合旧字串的全部字串替换为新的字串</p>
<p><strong>删除环境变量</strong>: <code>unset 变量名</code></p>
<p>我们在修改配置脚本后不会立即生效，可以使用<code>source file</code>来让其立即生效，source有个别名.，所以也可以这样写<code>. file</code></p>
<h2 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h2><p><code>whereis</code>:</p>
<ul>
<li>简单快速，直接从数据库进行查询。</li>
<li>只能搜索三种文件<ul>
<li>1.二进制文件(-b)</li>
<li>2.man帮助文件(-m)</li>
<li>3.源码文件(-s)</li>
</ul>
</li>
</ul>
<p><code>locate</code>:</p>
<ul>
<li>快而全，通过<code>/var/lib/mlocate/mlocate.db</code>数据库进行查找，不过这个数据库不是实时更新的，系统会使用定时任务每天自动执行<code>updatedb</code>更新一次，所以有时候刚添加的文件可能会找不到，需要手动执行一次<code>updatedb</code></li>
<li>用来查找指定目录下的不同文件类型</li>
<li>eg:<ul>
<li><code>locate /etc/sh</code>: 搜索.etc下所有以sh开头的文件，不止在/etc目录下查找，还会自动递归子目录进行查找</li>
<li><code>locate /usr/share/\*.jpg</code>: 搜索/usr/share/下所有jpg文件</li>
</ul>
</li>
<li>如果只是统计数目的话，加上<code>-c</code>参数，<code>-i</code>忽略大小写</li>
</ul>
<p><code>which</code>:</p>
<ul>
<li>小而精，它只从PATH环境变量指定的路径去搜索命令，通常用来确认是否安装了指定的软件</li>
<li>eg: <code>which man</code></li>
</ul>
<p><code>find</code>:</p>
<ul>
<li>精而细，非常强大，可以通过文件类型，文件名还有文件属性权限等进行查找</li>
<li>eg: <code>sudo find /etc/ -name interfaces</code> 在/etc/目录下搜索名字为interfaces的文件</li>
<li>与时间相关的命令参数:<ul>
<li><code>-atime</code>: 最后访问时间</li>
<li><code>-ctime</code>: 创建时间</li>
<li><code>-mtime</code>: 最后修改时间<ul>
<li><code>-mtime n</code>: 在n天之前的’一天之内’修改过的文件</li>
<li><code>-mtime +n</code>: 在n天之前(不包含n天)被修改过的文件</li>
<li><code>-mtime -n</code>: 在n天之内(包含n天)被修改的文件</li>
<li><code>newer file</code>: 列出比file还要新的文件</li>
<li>eg:<ul>
<li><code>find ~ -mtime 0</code> 列出home目录下，当天有改动的文件</li>
<li><code>find ~ newer /home/shiyanlou/Code</code>: 列出家目录下比Code文件夹新的文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件打包与压缩"><a href="#文件打包与压缩" class="headerlink" title="文件打包与压缩"></a>文件打包与压缩</h2><p><strong>打包和压缩的区别</strong>: 打包是指将一大堆文件或目录什么的变成一个总的文件，压缩则是将一个大的文件通过一些压缩算法变成一个小文件。为什么要区分这两个概念呢？其实这源于Linux中的很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你就得先借助另外的工具将这一大堆文件先打 成一个包，然后再就原来的压缩程序进行压缩</p>
<p><strong>压缩文件类型说明</strong>:<br><code>*.zip</code>: zip程序打包压缩的文件<br><code>*.rar</code>: rar程序压缩的文件<br><code>*.7z</code>: 7zip程序压缩的文件<br><code>*.tar</code>: tar程序打包，未压缩的文件<br><code>*.gz</code>: gzip程序压缩的文件<br><code>*.xz</code>: xz程序压缩的文件<br><code>*.bz2</code>: bzip2程序压缩的文件<br><code>*.tar.gz</code>: tar打包，gzip压缩的文件<br><code>*.tar.xz</code>: tar打包，xz程序压缩的文件<br><code>*.tar.bz2</code>: tar打包，bzip2程序压缩的文件<br><code>*.tar.7z</code>: tar打包，7z程序压缩的文件</p>
<p><strong>zip</strong>:<br>eg:</p>
<ul>
<li><code>zip -r -q -o shiyanlou.zip /home/shiyanlou</code>:<ul>
<li>将shiyanlou的home目录打包成一个文件</li>
<li><code>-r</code>表示递归打包包含子目录的全部内容</li>
<li><code>-q</code>表示安静模式</li>
<li><code>-o</code>表示输出文件需在其后紧跟打包输出文件名</li>
</ul>
</li>
<li><code>zip -r -9 -q -o shiyanlou._9.zip /home/shiyanlou -x ~/*.zip</code>:<ul>
<li><code>-9</code>–<code>-1</code>表示压缩级别，1表示最快压缩但体积大，9表示最慢但体积小</li>
<li><code>-x</code>为了排除目录下的zip文件，只能使用绝对路径</li>
<li>加上<code>-e</code>可以创建加密压缩包</li>
<li>加上<code>-l</code>参数将LF(Line-Feed: linux下的换行符)转换为CR+LF(Carriage-Return+Line-Feed: window下的换行符)</li>
</ul>
</li>
</ul>
<p><strong>unzip</strong>:<br>eg:</p>
<ul>
<li><code>unzip shiyanlou.zip</code>: 将shiyanlou.zip解压到当前目录</li>
<li><code>unzip -q shiyanlou.zip -d ziptest</code>: 使用安静模式，将文件解压到指定目录</li>
<li><code>unzip -l shiyanlou.zip</code>: 不解压，直接查看压缩包内容</li>
<li><code>unzip -O GBK 中文压缩文件.zip</code>: linux上面默认使用UTF-8编码，有可能出现中文乱码问题，用<code>-O</code>指定编码来解决</li>
</ul>
<p><strong>rar</strong>:<br>eg:</p>
<ul>
<li><code>rar a shiyanlou.rar .</code>: 使用<code>a</code>参数添加一个目录<code>~</code>到一个归档文件，<strong>注意</strong>rar命令参数没有<code>-</code>,加上会报错</li>
<li><code>rar d shiyanlou.rar .zshrc</code>: 指定压缩包删除某个文件</li>
<li><code>rar l shiyanlou.rar</code>: 不解压，直接查看内容</li>
</ul>
<p><strong>unrar</strong>:<br>eg:</p>
<ul>
<li><code>unrar x shiyanlou.rar</code>: 全路径解压</li>
<li><code>unrar e shiyanlou.rar tmp/</code>:去掉路径解压</li>
</ul>
<p><strong>tar</strong>:<br>eg:</p>
<ul>
<li><code>tar -cf shiyanlou.tar ~</code>:<ul>
<li>创建一个tar包</li>
<li><code>-c</code>表示创建一个tar包</li>
<li><code>-f</code>用于指定创建的文件名，必须紧跟在<code>-f</code>后面</li>
<li><code>-v</code>以可视的方式输出打包文件</li>
<li>上面的命令会自动去掉表示绝对路径的<code>/</code>,可以使用<code>-P</code>保留绝对路径符</li>
</ul>
</li>
<li><code>tar -xf shiyanlou.tar -C tardir</code>: 解包一个文件(<code>-x</code>参数)到指定路径的<strong>已存在</strong>目录(<code>-C</code>参数)</li>
<li><code>tar -tf shiyanlou.tar</code>: 只查看，不解包(<code>-t</code>参数)</li>
<li><code>tar -czf shiyanlou.tar.gz ~</code>:<ul>
<li>在创建tar文件的基础上添加<code>-z</code>参数，使用gzip来压缩文件。<code>-z</code>(<em>.tar.gz);`-J(</em>.tar.xz)<code>;</code>-j`(*.tar.bz2)</li>
</ul>
</li>
<li><code>tar -cxf shiyanlou.tar.gz</code>: 解压文件(<code>-x</code>参数)</li>
</ul>
<p><strong>常用命令组合</strong>:</p>
<ul>
<li><p><code>zip</code>:</p>
<ul>
<li>打包: <code>zip something.zip something</code>(目录应该加<code>-r</code>参数)</li>
<li>解包: <code>unzip something</code></li>
<li>指定目录: <code>-d</code>参数</li>
</ul>
</li>
<li><p><code>tar</code>:</p>
<ul>
<li>打包: <code>tar -zcvf something.tar something</code></li>
<li>解包: <code>tar -zxvf something.tar</code></li>
<li>指定目录: <code>-C</code>参数</li>
</ul>
</li>
</ul>
<h2 id="文件系统操作与磁盘管理"><a href="#文件系统操作与磁盘管理" class="headerlink" title="文件系统操作与磁盘管理"></a>文件系统操作与磁盘管理</h2><p><strong>df</strong>(report filr system disk space usage): 查看磁盘容量<br><strong>du</strong>(estimate file space usage): 查看目录容量</p>
<ul>
<li><code>-h</code>(human-readable): 人类易读的方式</li>
<li><code>-d</code>: 目录深度</li>
<li><code>-s</code>(summarize): 仅显示总计，只列出最后加总的值</li>
</ul>
<p><strong>dd</strong>:</p>
<ul>
<li>用来转换和复制文件。命令行格式为<code>选项=值</code></li>
<li><code>dd if=/dev/stdin of=test bs=10 count=1</code>:<ul>
<li><code>-if</code>(input file): 输入文件</li>
<li><code>-of</code>(output file): 输出文件</li>
<li><code>-bs</code>(blocks size): 块大小，默认为Byte，可以指定为K，M，G等</li>
<li><code>-count</code>: 块的数量</li>
</ul>
</li>
<li><code>dd if=test of=TEST bs=5 count=1 conv=ucase</code>: <code>-conv</code>转换函数</li>
<li><code>dd if=/dev/zero of=virtual.img bs=1M count=256</code>: 创建一个容量为256M的空文件</li>
</ul>
<p><strong>黑底百分号表示这里没有换行符</strong></p>
<p><strong>mkfs</strong>: <code>sudo mkfs.ext4 virtual.img</code>: 格式化磁盘<br><strong>mount</strong>:</p>
<ul>
<li><code>sudo mount</code>: 查看以挂载的文件系统</li>
<li><code>mount -o loop -t ext4 virtual.img /mnt</code>: 将虚拟磁盘镜像挂载到/mnt目录</li>
</ul>
<p><strong>unmount</strong>: <code>sudo unmount /mnt</code>: 卸载以挂载磁盘<br><strong>fdisk</strong>:</p>
<ul>
<li><code>sudo fdisk -l</code>: 查看磁盘分区表信息</li>
<li><code>sudo fdisk virtual.img</code>: 进入磁盘分区模式</li>
</ul>
<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p><strong>内建命令与外部命令的区别</strong>:</p>
<ul>
<li>内建命令实际上是 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令，这些命令是写在bash源码的builtins里面的，并由 shell 程序识别并在 shell 程序内部完成运行，通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快。比如：history、cd、exit 等等。</li>
<li>外部命令是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调用内存。虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的。外部命令是在 Bash 之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin等等。比如：ls、vi等。</li>
<li>用<code>type</code>命令来查看命令的类型</li>
</ul>
<p><strong>帮助命令</strong>:</p>
<ul>
<li><code>help</code>: 用于显示shell<strong>内建命令</strong>的简要帮助信息。对于外部命令，命令本身会有一个<code>--help</code>参数用来查看帮助</li>
<li><code>man</code>: 内容比<code>help</code>详细得多</li>
<li><code>info</code>: 信息比<code>man</code>更详细</li>
</ul>
<h2 id="任务计划crontab"><a href="#任务计划crontab" class="headerlink" title="任务计划crontab"></a>任务计划crontab</h2><p><strong>命令格式</strong>:<br># Example of job definition:<br># .—————- minute (0 - 59)<br># |  .————- hour (0 - 23)<br># |  |  .———- day of month (1 - 31)<br># |  |  |  .——- month (1 - 12) OR jan,feb,mar,apr …<br># |  |  |  |  .—- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat<br># |  |  |  |  |<br># <em>  </em>  <em>  </em>  * user-name command to be executed</p>
<p><code>sudo service rsyslog start</code>: 启动rsyslog，以便我们可以通过日志中的信息来了解任务是否真的执行了<br><code>sudo cron -f &amp;</code>: 启动crontab服务，<code>&amp;</code>放在命令参数后面表示该命令在后台运行<br><code>crontab -e</code>: 添加计划任务<br><code>*/1 * * * * touch /home/shiyanlou/$(date +\%Y\%m\%d\%H\%M\%S)</code>: 添加任务命令</p>
<p><strong>注意</strong>: <code>%</code>在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加<code>\</code>符号转义，否则，<code>%</code>符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。<br><code>crontab -l</code>: 查看添加了那些任务<br><code>crontab -r</code>: 删除任务</p>
<p>如果是系统级别的任务，只需要编辑<code>/etc/crontab</code>文件就可以<br>cron服务检测时间最小单位是分钟，所以cron每分钟去读取一次<code>/etc/crontab</code>与<code>/var/spool/cron/crontabs</code>里面的内容</p>
<h2 id="命令执行顺序控制与管道"><a href="#命令执行顺序控制与管道" class="headerlink" title="命令执行顺序控制与管道"></a>命令执行顺序控制与管道</h2><p><strong>顺序执行多条命令</strong>: eg: <code>sudo apt install update; sudo apt install some-tool; some-tool</code><br><strong>有选择的执行命令</strong>:</p>
<ul>
<li>eg:<ul>
<li><code>which cowsay&gt;/dev/null &amp;&amp; cowsay -f head-in ohch~</code></li>
<li><code>which cowsay&gt;/dev/null &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot;</code></li>
</ul>
</li>
</ul>
<p><strong>cut</strong>:</p>
<ul>
<li><code>cut /etc/passwd -d &#39;:&#39; -f 1,6</code>: 打印<code>/etc/passwd</code>文件中以<code>:</code>为分隔符的第一字段和第六字段</li>
<li>打印<code>/etc/passwd</code>文件中每一行的前N个字符<ul>
<li><code>cut /etc/passwd -c -5</code>: 前五个(包含第五个)</li>
<li><code>cut /etc/passwd -c 5-</code>: 前五个之后的(包含第五个)</li>
<li><code>cut /etc/passwd -c 5</code>: 第五个</li>
<li><code>cut /etc/passwd -c 2-5</code>: 2到5之间的(包含第五个)</li>
</ul>
</li>
</ul>
<p><strong>grep</strong>:</p>
<ul>
<li><code>grep -rnI &quot;shiyanlou&quot; ~</code>:<ul>
<li><code>-r</code>: 表示递归搜索子目录的文件</li>
<li><code>-n</code>: 表示打印匹配项行号</li>
<li><code>-I</code>: 表示忽略二进制文件</li>
</ul>
</li>
</ul>
<p><strong>wc</strong>: 用于统计一个文件中行，单词和字节的数目</p>
<ul>
<li><code>wc /etc/passwd</code>: 输出<code>/etc/passwd</code>文件的统计信息<ul>
<li><code>-l</code>: 行数</li>
<li><code>-w</code>: 单词数</li>
<li><code>-c</code>: 字节数</li>
<li><code>-m</code>: 字符数</li>
<li><code>-L</code>: 最长行字节数</li>
</ul>
</li>
</ul>
<p><strong>sort</strong>: 将输入按照一定方式排序，然后再输出，支持的排序有字典排序(默认)、按月份排序、随即排序、反转排序、指定字段进行排序等等</p>
<ul>
<li><code>cat /etc/passwd | sort</code>: 字典排序</li>
<li><code>cat /etc/passwd | sort -r</code>: 反转排序</li>
<li><code>cat /etc/passwd | sort -t&#39;:&#39; -k 3</code>:<ul>
<li><code>-t</code>用来指定字段的分隔符</li>
<li><code>-k 字段号</code>指定对哪个字段进行排序</li>
</ul>
</li>
</ul>
<p><strong>uniq</strong>: 用于过滤或输出重复行(只能去除连续重复的行)</p>
<ul>
<li><code>history | cut -c 8- | cut -d &#39; &#39; -f 1 | uniq</code>: 输出执行命令的那一列</li>
<li><code>history | cut -c 8- | cut -d &#39; &#39; -f 1 | sort | uniq</code>: 输出执行命令的那一列(没有重复的)</li>
<li><code>history | cut -c 8- | cut -d &#39; &#39; -f 1 | uniq -dc</code>: 输出重复过的行和重复次数</li>
<li><code>history | cut -c 8- | cut -d &#39; &#39; -f 1 | uniq -D</code>: 输出所有重复的行</li>
</ul>
<h2 id="简单的文本处理"><a href="#简单的文本处理" class="headerlink" title="简单的文本处理"></a>简单的文本处理</h2><p><strong>tr</strong>:</p>
<ul>
<li><code>tr [option]...SET1 [SET2]</code><ul>
<li><code>-d</code>: 删除和set1匹配的字符，感觉向正则表达式<code>[set1]</code>一样</li>
<li><code>-s</code>: 去除set1指定的在输入文本中连续并重复的字符(去连续重只剩一个？)</li>
</ul>
</li>
<li>eg:<ul>
<li><code>echo &quot;helo shiyanlou&quot; | tr -d &#39;olh&#39;</code></li>
<li><code>echo &#39;hello&#39; | tr -s &#39;l&#39;</code></li>
<li><code>cat /etc/passwd | tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;</code>: 将所有小写转换为大写，也可以简单的写成<code>&#39;[a-z]&#39;</code> <code>&#39;[A-Z]&#39;</code></li>
</ul>
</li>
</ul>
<p><strong>col</strong>:</p>
<ul>
<li>将<code>Tab</code>转换成等数量的空格键，或者翻转这个操作<ul>
<li><code>-x</code>: 将<code>Tab</code>转换为空格</li>
<li><code>-h</code>: 将空格转换为<code>Tab</code>(默认选项)</li>
</ul>
</li>
<li>eg:<ul>
<li><code>cat -A /etc/protocols</code>: 查看/etc/protocols中的不可见字符，可以看到很多^I，这是tab转义成可见字符的符号</li>
<li><code>cat /etc/protocols | col -x | cat -A</code>: 经过<code>col</code>转换后看不见^I了</li>
</ul>
</li>
</ul>
<p><strong>join</strong>:</p>
<ul>
<li>将两个文件中包含相同内容的那一行合并在一起，我想是根据分隔符(默认为空格),比对指定字段(默认为第一字段),若比对字段相同则将比对字段放到合并后的行头，后面一次跟着对应文件的剩余部分<ul>
<li><code>-t</code>: 指定分隔符，默认为空格</li>
<li><code>-i</code>: 忽略大小写</li>
<li><code>-1</code>: 指明第一个文件的比对字段，默认为第一字段</li>
<li><code>-2</code>: 指明第二个文件的比对字段，默认为第一字段</li>
</ul>
</li>
<li>eg:<ul>
<li><code>sudo join -t &#39;:&#39; /etc/passwd /etc/shadow</code></li>
<li><code>sudo join -t &#39;:&#39; -1 4 /etc/passwd -2 3 /etc/group</code></li>
</ul>
</li>
</ul>
<p><strong>paste</strong>:</p>
<ul>
<li>与<code>join</code>命令类似，不过它不进行比对，只是简单的将多个文件合并到一起，默认以<code>Tab</code>分隔符隔开<ul>
<li><code>-d</code>: 指定分隔符，默认为tab</li>
<li><code>-s</code>: 不合并到一行，每个文件为一行</li>
</ul>
</li>
<li>eg:<ul>
<li><code>paste -d &#39;:&#39; file1 file2 file3</code></li>
<li><code>paste -s file1 file2 file3</code></li>
</ul>
</li>
</ul>
<h2 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h2><p><strong>文件描述符</strong>: 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</p>
<table>
<thead>
<tr>
<th>文件描述符</th>
<th style="text-align:center">设备文件</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td style="text-align:center"><code>/dev/stdin</code></td>
<td style="text-align:right">标准输入</td>
</tr>
<tr>
<td><code>1</code></td>
<td style="text-align:center"><code>/dev/stdout</code></td>
<td style="text-align:right">标准输出</td>
</tr>
<tr>
<td><code>2</code></td>
<td style="text-align:center"><code>/dev/stderr</code></td>
<td style="text-align:right">标准错误</td>
</tr>
</tbody>
</table>
<p><code>cat &gt; Documents/test.c &lt;&lt; EOF</code>: cat的连续输出(heredoc方式)重定向到一个文件</p>
<p><code>cat Documents/test.c hello.c &gt;somefile 2&gt;&amp;1</code>: 将标准错误重定向到标准输出，再将标准输出重定向到文件。或者可以用<code>&amp;&gt;somefile</code>表示将标准错误和标准输出同时重定向到文件</p>
<p><code>echo &#39;hello shiyanlou&#39; | tee hello</code>: 将输出重定向到文件的同时也将信息打印在终端</p>
<p><code>exec 1&gt;somefile</code>: “永久”重定向，<code>exec</code>作用是使用指定的命令替换当前的shell，及使用一个进程替换当前进程，或者指定新的重定向。这个命令使得后面的命令输出全部重定向到文件</p>
<p><code>/dev/null</code>: 在类 UNIX 系统中，/dev/null，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个EOF。</p>
<p><code>xargs</code>: xargs 是一条 UNIX 和类 UNIX 操作系统的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。</p>
<ul>
<li><code>cut -d: -f1 &lt; /etc/passwd | sort | xargs echo</code>: 将/etc/passwd文件按<code>:</code>分割取第一个字段排序后，使用<code>echo</code>命令生成一个列表</li>
</ul>
<h2 id="grep-sed-awk"><a href="#grep-sed-awk" class="headerlink" title="grep sed awk"></a>grep sed awk</h2><p><strong>grep</strong>:</p>
<ul>
<li>常用参数:<ul>
<li><code>-b</code>: 将二进制文件作为文本来进行匹配</li>
<li><code>-c</code>: 统计以模式匹配的数目</li>
<li><code>-i</code>: 忽略大小写</li>
<li><code>-n</code>: 显示匹配文本所在的行号</li>
<li><code>-v</code>: 反选，输出不匹配行的内容</li>
<li><code>-r</code>: 递归匹配查找</li>
<li><code>-A n</code>: n为正整数，表示after，除了列出匹配行外，还列出后面的n行</li>
<li><code>-B n</code>: n为正整数，表示before，除了列出匹配行外，还列出前面的n行</li>
<li><code>--color=auto</code>: 将输出中的匹配项设置为自动颜色显示</li>
</ul>
</li>
<li>支持三种正则表达式引擎<ul>
<li><code>-E</code>: POSIX扩展正则表达式,ERE.通过grep使用扩展正则表达式需要加上<code>-E</code>参数，或者使用egrep</li>
<li><code>-G</code>: POSIX基本正则表达式，BRE</li>
<li><code>-P</code>: Perl正则表达式,PCRE</li>
</ul>
</li>
<li>eg:<ul>
<li><code>echo &#39;1234/nabcd&#39; | grep &#39;[[:digit:]]&#39;</code>: 匹配所有数字</li>
</ul>
</li>
<li>特殊符号: 之所以要使用特殊符号，是因为上面的<code>[a-z]</code>不是在所有情况下都管用，这还与主机当前的语系有关，即设置在LANG环境变量的值，zh_CN.UTF-8的话<code>[a-z]</code>，即为所有小写字母，其它语系可能是大小写交替的如，”a A b B…z Z”，<code>[a-z]</code>中就可能包含大写字母。所以在使用<code>[a-z]</code>时请确保当前语系的影响，使用<code>[:lower:]</code>则不会有这个问题。<ul>
<li><code>[:alnum:]</code>: 代表英文大小写字母和数字</li>
<li><code>[:alpha:]</code>: 代表任何英文大小写字母</li>
<li><code>[:blank:]</code>: 代表空白键和Tab键</li>
<li><code>[:cntrl:]</code>: 代表键盘的控制按键，CR,LF,Tab,Del…等等</li>
<li><code>[:digit:]</code>: 数字</li>
<li><code>[:graph:]</code>: 除了空白字节(空格和Tab)外的所有按键</li>
<li><code>[:lower:]</code>: 小写字母</li>
<li><code>[:print:]</code>: 任何可以被打印出来的字节</li>
<li><code>[:punct:]</code>: 标点符号(punctuation symbol)，即:”‘?!:#$等</li>
<li><code>[:upper:]</code>: 大写字母</li>
<li><code>[:space:]</code>: 任何会产生空白的字节，包括空白键，Tab，CR等等</li>
<li><code>[:xdigit:]</code>: 16进位的数字类型</li>
</ul>
</li>
</ul>
<p><strong>sed</strong>: (stream editor for filtering and transforming text)即用于过滤和转换文本的流编辑器</p>
<ul>
<li>基本命令格式: <code>sed [参数]... [执行命令] [输入文件]...</code></li>
<li>参数:<ul>
<li><code>-n</code>: 安静模式，只打印受影响的行，默认打印输入数据的全部内容</li>
<li><code>-e</code>: 用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要添加该参数</li>
<li><code>-f(filename)</code>: 执行指定文件中的命令</li>
<li><code>-r</code>: 使用扩展正则表达式，默认为标准正则表达式</li>
<li><code>-i</code>: 直接修改输入文件内容，而不是打印到标准输出设备</li>
</ul>
</li>
<li>执行命令格式:<ul>
<li><code>[n1][,n2]command</code>: 从n1到n2行</li>
<li><code>[n1][~step]command</code>: 从n1行开始以step为步进的所有行</li>
<li>常用动作指令:<ul>
<li><code>s</code>: 行内替换</li>
<li><code>c</code>: 整行替换</li>
<li><code>a</code>: 插入到指定行的后面</li>
<li><code>i</code>: 插入到指定行的前面</li>
<li><code>p</code>: 打印指定行，通常与<code>-n</code>参数配合使用</li>
<li><code>d</code>: 删除指定行</li>
</ul>
</li>
</ul>
</li>
<li>eg:<ul>
<li><code>sed -i &#39;s/sad/happy/g&#39; test</code>: g表示全局范围</li>
<li><code>sed -i &#39;s/sad/happy/4&#39; test</code>: 4表示指定行中的第四个匹配字符串</li>
<li><code>sed -i &#39;1s/sad/happy/&#39; test</code>: 把第一行的sad替换成happy</li>
<li><code>nl passwd | sed -n &#39;2,5p&#39;</code>: 打印2-5行</li>
<li><code>nl passwd | sed -n &#39;1~2p&#39;</code>: 打印奇数行</li>
<li><code>sed -n &#39;s/shiyanlou/hehe/gp&#39; passwd</code>: 输入文本中的shiyanlou全局替换成hehe，并只打印替换的那一行</li>
</ul>
</li>
</ul>
<p><strong>awk</strong>: awk所有的操作都是基于pattern(模式)—action(动作)对来完成的，如下面的形式<code>$ pattern {action}</code>你可以看到就如同很多编程语言一样，它将所有的动作操作用一对{}花括号包围起来。其中pattern通常是是表示用于匹配输入的文本的“关系式”或“正则表达式”，action则是表示匹配后将执行的动作。在一个完整awk操作中，这两者可以只有其中一个，如果没有pattern则默认匹配输入的全部文本，如果没有action则默认为打印匹配内容到屏幕。</p>
<ul>
<li>基本命令格式: <code>awk [-F fs] [-v var=value] [-f prog-file | &#39;program text&#39;] [file...]</code><ul>
<li><code>-F</code>: 预先指定字段分隔符，默认为空格</li>
<li><code>-v</code>: 预先指定变量</li>
<li><code>-f</code>: 指定要执行的程序文件，不加此参数，直接把语句写在这里</li>
</ul>
</li>
<li>常用的内置变量<ul>
<li><code>FILENAME</code>: 当前输入文件名，若有多个为第一个，如果输入来自标准输入，为空字符串</li>
<li><code>$0</code>: 当前记录的内容</li>
<li><code>$N</code>: N表示字段号，最大值为NF变量的值</li>
<li><code>FS</code>(file separator): 字段分隔符，由正则表达式表示，默认为空格</li>
<li><code>RS</code>(input record separator): 输入记录分隔符，默认为’\n’，即一行为一个记录</li>
<li><code>NF</code>(number of fields in the current record): 当前记录字段数</li>
<li><code>NR</code>(current record number in the total input stream): 已经读入的记录数</li>
<li><code>FNR</code>(current record number in FILENAME): 当前输入文件的记录数</li>
<li><code>OFS</code>: 输出字段分隔符，默认为空格</li>
<li><code>ORS</code>: 输出记录分隔符，默认为’\n’</li>
</ul>
</li>
</ul>
<h2 id="Linux进程"><a href="#Linux进程" class="headerlink" title="Linux进程"></a>Linux进程</h2><p>让命令在后台运行:</p>
<ul>
<li>加<code>&amp;</code></li>
<li>通过<code>ctrl + z</code></li>
</ul>
<p>通过<code>pstree</code>来查看当前活跃进程的树形结构<br>通过<code>jobs</code>查看被停止并放置在后台的工作<br>通过<code>fg [%jobnumber]</code>将后台的工作拿到前台来<br>通过<code>bg [%jobnumber]</code>将前台的工作放到后台<br>通过<code>kill -signal %jobnumber</code>删除或重启，通过<code>kill -l</code>查看信号值，常用的有:</p>
<ul>
<li>-1: 重新读取参数运行，类似restart</li>
<li>-2: 如同ctrl+c 的操作退出</li>
<li>-9: 强制终止该任务</li>
<li>-15: 正常的方式终止该任务</li>
</ul>
<p>若是在使用kill＋信号值然后直接加数字的话，这个数字代表的是 pid，你将会对 pid 对应的进程做操作<br>若是在使用kill+信号值然后％jobnumber，这时所操作的对象才是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID</p>
<p>进程的查看:</p>
<ul>
<li>top: 实时查看我们系统一些关键信息的变化，例如运行的进程中的实时变化<ul>
<li>第一行: 系统相关信息</li>
<li>第二行: 进程统计</li>
<li>第三行: CPU使用情况统计</li>
<li>第四行: 内存使用情况统计</li>
<li>第五行: 交换区的使用情况统计</li>
<li>下面就是进程的情况</li>
</ul>
</li>
<li>ps:<ul>
<li><code>ps aux</code>: 罗列出所有进程信息</li>
<li><code>ps axjf</code>: 查看同时将连同部分的进程呈树状显示出来</li>
<li><code>ps -l</code>: 显示自己这次登陆的bash相关的进程信息罗列出来</li>
<li><code>ps -afxo user,ppid,pid,pgid,command</code>: 自定义我们需要的参数显示</li>
</ul>
</li>
<li>pstree: 树状显示进程<ul>
<li><code>-A</code>: 各程序树之间以ASCII字元来连接</li>
<li><code>-u</code>: 同时列出每个process的PID</li>
<li><code>-p</code>: 同时列出每个process的所属账户名称</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux学习记录--有趣的linux命令]]></title>
      <url>/2017/04/09/Linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95--%E6%9C%89%E8%B6%A3%E7%9A%84linux%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="输出图形字符的命令"><a href="#输出图形字符的命令" class="headerlink" title="输出图形字符的命令"></a>输出图形字符的命令</h2><p><strong>banner</strong>:</p>
<ul>
<li>安装: <code>sudo apt install sysvbanner</code></li>
<li>eg: <code>banner linux</code></li>
<li><img src="/2017/04/09/Linux学习记录--有趣的linux命令/banner.png" alt=""></li>
</ul>
<p><strong>printerbanner</strong>:</p>
<ul>
<li>eg: <code>printerbanner -w 30 A</code> <code>-w</code>指定宽度</li>
<li><img src="/2017/04/09/Linux学习记录--有趣的linux命令/printerbanner.png" alt=""></li>
</ul>
<p><strong>toilet</strong>:</p>
<ul>
<li>eg: <code>toilet love</code></li>
<li><img src="/2017/04/09/Linux学习记录--有趣的linux命令/toilet.png" alt=""></li>
</ul>
<p><strong>figlet</strong>:</p>
<ul>
<li>eg: <code>figlet love</code></li>
<li><img src="/2017/04/09/Linux学习记录--有趣的linux命令/figlet.png" alt=""></li>
</ul>
<h2 id="监督你的眼睛"><a href="#监督你的眼睛" class="headerlink" title="监督你的眼睛"></a>监督你的眼睛</h2><p><code>xeyes</code><br>后台运行: <code>nohup xeyes &amp;</code><br>只能运行在图形界面</p>
<h2 id="数字雨"><a href="#数字雨" class="headerlink" title="数字雨"></a>数字雨</h2><p><code>cmatrix</code><br><img src="/2017/04/09/Linux学习记录--有趣的linux命令/cmatrix.png" alt=""></p>
<h2 id="跳动的火焰"><a href="#跳动的火焰" class="headerlink" title="跳动的火焰"></a>跳动的火焰</h2><p><code>aafire</code><br>安装: <code>sudo apt install libaa-bin</code><br><img src="/2017/04/09/Linux学习记录--有趣的linux命令/aafire.gif" alt=""></p>
<h2 id="幸运饼干"><a href="#幸运饼干" class="headerlink" title="幸运饼干"></a>幸运饼干</h2><p><code>fortune</code>: 打印出一段随机的名言<br><img src="/2017/04/09/Linux学习记录--有趣的linux命令/fortune.png" alt=""></p>
<h2 id="以动物说话形式打印出一段话"><a href="#以动物说话形式打印出一段话" class="headerlink" title="以动物说话形式打印出一段话"></a>以动物说话形式打印出一段话</h2><p><code>cowsay</code><br><code>cowsay -l</code>: 打印出所有支持的动物种类<br><code>cowsay -f elephant hello world</code>: <code>-f</code>指定动物类型<br><code>fortune | cowsay -f daemon</code>: 可以与<code>fortune</code>命令相结合<br><img src="/2017/04/09/Linux学习记录--有趣的linux命令/cowsay.png" alt=""></p>
<h2 id="Space-Invaders"><a href="#Space-Invaders" class="headerlink" title="Space Invaders"></a>Space Invaders</h2><p><code>ninvaders</code><br><img src="/2017/04/09/Linux学习记录--有趣的linux命令/ninvaders.gif" alt=""></p>
<h2 id="彩色的火焰"><a href="#彩色的火焰" class="headerlink" title="彩色的火焰"></a>彩色的火焰</h2><p><code>cacafire</code><br>安装: <code>sudo apt install caca-utils</code><br><img src="/2017/04/09/Linux学习记录--有趣的linux命令/cacafire.gif" alt=""></p>
<h2 id="bb"><a href="#bb" class="headerlink" title="bb"></a>bb</h2><p><code>bb</code><br><img src="/2017/04/09/Linux学习记录--有趣的linux命令/bb.gif" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux学习记录--常用命令简记]]></title>
      <url>/2017/03/30/Linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95--%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AE%80%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>命令格式为: 命令名称 [命令参数] [命令对象]，之间以空格隔开。命令参数可以选用<strong>长格式</strong>(完整的选项名称)或者<strong>短格式</strong>(单个字母的缩写)，分别用<code>--</code>和<code>-</code>做前缀</p>
<h3 id="日常使用命令记录"><a href="#日常使用命令记录" class="headerlink" title="日常使用命令记录"></a>日常使用命令记录</h3><p>1、使用关键字pkg搜索软件包: <code>sudo apt-cache search &lt;pkg&gt;</code><br>2、查看当前系统可用命令: <code>compgen -c</code><br>3、以名称查找某个文件: <code>sudo find &lt;目录&gt; -name &lt;文件名(可以使用正则，要用双引号包起来)&gt;</code></p>
<h3 id="快捷键命令"><a href="#快捷键命令" class="headerlink" title="快捷键命令"></a>快捷键命令</h3><p>1、<code>alt + F4</code>: 关闭当前窗口<br>2、<code>alt + tab</code>: 窗口间切换，按<code>shift</code>反向移动<br>3、<code>alt + \``: 在同一个应用程序的不同窗口间切换
4、</code>super + w<code>: 显示当前工作区所有窗口
5、</code>ctrl + super + d<code>: 隐藏/显示桌面
6、</code>ctrl + alt + l<code>: 锁定屏幕
7、</code>ctrl + alt + <f1~f7><code>: 切换字符/图形界面，</code>F7`是图形，其他是字符</f1~f7></p>
<h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><ol>
<li><strong>man</strong>: <code>Manual pages</code><br>用man命令来查询陌生命令的可用参数和用法<br>有几个操作按钮:<ul>
<li>/关键词: 从上至下搜索某个关键词</li>
<li>?关键词: 从下至上搜索某个关键词</li>
<li>q: 退出帮助文档</li>
</ul>
</li>
</ol>
<h3 id="常用系统命令"><a href="#常用系统命令" class="headerlink" title="常用系统命令"></a>常用系统命令</h3><ol>
<li><p><strong>echo</strong><br>用来在终端显示字符串或者变量</p>
</li>
<li><p><strong>date</strong><br>按照指定格式显示系统时间或日期，需要键入+号开头的字符串指定其格式<br>简单的列出几个格式:</p>
<ul>
<li>%H: 小时(00-23)</li>
<li>%l: 小时(01-12)</li>
<li>%M: 分钟(00-59)</li>
<li>%S: 秒(00-60)</li>
<li>%X: 相当于%H:%M:%S</li>
<li>%Z: 显示时区</li>
<li>%Y: 完整的年份</li>
<li>%B: 完整的月份(January-December)</li>
<li>%b: 缩写的月份(Jan-Dec)</li>
<li>%m: 月份(01-12)</li>
<li>%d: 日(01-31)</li>
</ul>
</li>
<li><p><strong>reboot</strong><br>重启，仅root用户可用</p>
</li>
<li><p><strong>wget</strong><br>使用命令行下载网络文件<br>wget [参数] 下载地址<br>参数:</p>
<ul>
<li>-b: 后台下载</li>
<li>-O: 下载到指定目录</li>
<li>-t: 最大尝试次数</li>
<li>-c: 断点续传</li>
<li>-p: 下载页面所有资源</li>
<li>-r: 递归下载</li>
</ul>
</li>
<li><p><strong>elinks</strong><br>一个纯文本界面的浏览器，格式为<br>elinks [参数] 网址</p>
</li>
</ol>
<h3 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h3><ol>
<li><p><strong>ifconfig</strong><br>获取网卡配置与网络状态等信息<br>ifconfig [网络设备] [参数]</p>
</li>
<li><p><strong>uname</strong><br>查看系统内核版本等信息<br>uname [-a]</p>
</li>
<li><p><strong>uptime</strong><br>查看系统负载情况<br>uptime<br>watch -n 1 uptime: 每秒刷新一次当前的系统负载情况</p>
</li>
<li><p><strong>free</strong><br>显示当前系统中内存的使用量情况<br>free [-m/-g] m g 为字节单位</p>
</li>
<li><p><strong>who</strong><br>查看当前登入主机的用户情况<br>who [参数]</p>
</li>
<li><p><strong>last</strong><br>查看所有的系统登陆记录<br>last [参数]</p>
</li>
<li><p><strong>history</strong><br>显示历史执行过的命令<br>history [-c] 默认保存1000条</p>
</li>
<li><p><strong>sosreport</strong><br>收集系统配置并诊断信息后输出结论文档</p>
</li>
</ol>
<h3 id="工作目录切换命令"><a href="#工作目录切换命令" class="headerlink" title="工作目录切换命令"></a>工作目录切换命令</h3><ol>
<li><p><strong>pwd</strong><br>显示当前工作目录<br>pwd [选项]<br>参数: -P 显示真实路径(即非快捷链接的地址)</p>
</li>
<li><p><strong>cd</strong><br>切换工作目录<br>cd [目录名称]<br>参数:</p>
<ul>
<li>- : 上一次的目录</li>
<li>~ : 家目录</li>
<li>~username: 其他用户的家目录</li>
<li>.. : 上级目录</li>
</ul>
</li>
<li><p><strong>ls</strong><br>查看当前目录有哪些文件<br>ls [选项] [文件]<br>参数:</p>
<ul>
<li>-a : 全部文件</li>
<li>-d : 仅看目录本身</li>
<li>-h : 易读的文件容量</li>
<li>-l : 显示文件的详细信息</li>
</ul>
</li>
</ol>
<h3 id="文本文件编辑命令"><a href="#文本文件编辑命令" class="headerlink" title="文本文件编辑命令"></a>文本文件编辑命令</h3><ol>
<li><p><strong>cat</strong><br>用于查看纯文本文件(较短的)<br>cat [选项] [文件]<br>参数:</p>
<ul>
<li>-n : 显示行号</li>
<li>-b : 显示行号(不包括空行)</li>
<li>-A : 显示出不可见的符号，空格、tab等</li>
</ul>
</li>
<li><p><strong>more</strong><br>查看纯文本文件(较长的)<br>more [选项] [文件]<br>参数:</p>
<ul>
<li>-数字: 预先显示的行数</li>
<li>-d: 显示提示语句和报错信息</li>
</ul>
</li>
<li><p><strong>head</strong><br>查看纯文本文档的前N行<br>head [选项] [文件]<br>参数:</p>
<ul>
<li>-n 10 : 显示10行</li>
<li>-n -10 : 正常输出，不显示后面10行</li>
</ul>
</li>
<li><p><strong>tail</strong><br>查看纯文本文档的后N行<br>tail [选项] [文件]<br>参数:</p>
<ul>
<li>-n 10 : 显示后面10行</li>
<li>-f : 持续刷新显示的内容</li>
</ul>
</li>
<li><p><strong>od</strong><br>查看特殊格式的文件<br>od [选项] [文件]<br>参数:</p>
<ul>
<li>-t a : 默认字符</li>
<li>-t c : ASCII字符</li>
<li>-t o : 八进制</li>
<li>-t d : 十进制</li>
<li>-t x : 十六进制</li>
<li>-t f : 浮点数</li>
</ul>
</li>
<li><p><strong>tr</strong><br>转换文本文件中的字符<br>tr [原始字符] [目标字符]</p>
</li>
<li><p><strong>wc</strong><br>统计指定文本的行数、字数、字节数<br>wc [参数] 文本<br>参数:</p>
<ul>
<li>-l : 只显示行数</li>
<li>-w : 只显示单词数</li>
<li>-c : 只显示字节数</li>
</ul>
</li>
<li><p><strong>cut</strong><br>通过列来提取文本字符<br>cut [参数] 文本<br>参数:</p>
<ul>
<li>-d 分隔符 : 指定分隔符，默认为tab</li>
<li>-f : 指定显示的列数</li>
<li>-c : 单位改为字符</li>
</ul>
</li>
<li><p><strong>diff</strong><br>比较多个文本文件的差异<br>diff [参数] 文本<br>参数:</p>
<ul>
<li>-b : 忽略空格引起的差异</li>
<li>-B : 忽略空行引起的差异</li>
<li>-brief 或 -q : 仅报告是否存在差异</li>
<li>-c : 使用上下文输出格式</li>
</ul>
</li>
</ol>
<h3 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h3><ol>
<li><p><strong>touch</strong><br>创建空白文件与修改文件时间<br>touch [选项] [文件]<br>参数:</p>
<ul>
<li>-a : 修改访问时间(atime)</li>
<li>-m : 修改更改时间(mtime)</li>
<li>-d : 同时修改atime和mtime</li>
<li>-t : 修改生成的时间</li>
</ul>
</li>
<li><p><strong>mkdir</strong><br>创建空白的文件夹<br>mkdir [选项] 目录</p>
</li>
<li><p><strong>cp</strong><br>复制文件或目录<br>cp [选项] 源文件 目标文件<br>有三种情况:</p>
<ul>
<li>目标文件为一个目录，源文件复制进去</li>
<li>目标文件为一个文件，覆盖掉</li>
<li>目标文件不存在，复制一份源文件并以目标文件命名</li>
</ul>
</li>
<li><p><strong>mv</strong><br>移动文件或改名<br>mv [选项] 文件名 [目标路径|目标文件名]</p>
</li>
<li><p><strong>rm</strong><br>删除文件或目录<br>rm [选项] 文件<br>参数:</p>
<ul>
<li>-f : 忽略警告信息</li>
<li>-i : 删除前先询问</li>
<li>-r : 删除文件夹</li>
</ul>
</li>
<li><p><strong>dd</strong><br>指定大小的拷贝文件或指定转换文件<br>dd [参数]</p>
</li>
</ol>
<h3 id="用户与组管理命令"><a href="#用户与组管理命令" class="headerlink" title="用户与组管理命令"></a>用户与组管理命令</h3><ol>
<li><p><strong>useradd</strong><br>创建新的用户<br>useradd [选项] 用户名</p>
</li>
<li><p><strong>passwd</strong><br>修改用户密码<br>passwd [选项] 用户名</p>
</li>
<li><p><strong>userdel</strong><br>删除用户所有表格<br>userdel [选项] 用户名</p>
</li>
<li><p><strong>usermod</strong><br>修改用户属性<br>usermod [选项] 用户名</p>
</li>
<li><p><strong>groupadd</strong><br>创建群组<br>groupadd [选项] 群组名</p>
</li>
</ol>
<h3 id="打包压缩文件民命令"><a href="#打包压缩文件民命令" class="headerlink" title="打包压缩文件民命令"></a>打包压缩文件民命令</h3><ol>
<li><strong>tar</strong><br>打包压缩或解压<br>tar [选项] 文件</li>
</ol>
<h3 id="文件查询搜索命令"><a href="#文件查询搜索命令" class="headerlink" title="文件查询搜索命令"></a>文件查询搜索命令</h3><ol>
<li><p><strong>grep</strong><br>对文本进行搜索<br>grep [选项] 文件</p>
</li>
<li><p><strong>find</strong><br>find [查找路径] 寻找条件 操作</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《学习JavaScript数据结构与算法》读书笔记--队列]]></title>
      <url>/2017/03/29/%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>队列和栈很相似，不过队列遵循的是先进先出(FIFO)的原则。队列在尾部添加新元素，并从顶部移除元素。新添加的元素必须排在队列的末尾</p>
<p><strong>优先队列</strong>: 元素的添加和移除是基于优先级的。有两种实现方式</p>
<ul>
<li>设置优先级，在正确的位置添加元素</li>
<li>用正常的入列操作添加元素，按照优先级进行移除</li>
</ul>
<h2 id="简单代码实现"><a href="#简单代码实现" class="headerlink" title="简单代码实现"></a>简单代码实现</h2><p>传统队列<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Queue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存放队列元素</span></span><br><span class="line">  <span class="keyword">var</span> items = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向队列末尾添加一个元素</span></span><br><span class="line">  <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    items.push(element);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从队列顶部移除一个元素并返回</span></span><br><span class="line">  <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.shift();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查看队列顶部第一个元素，不改变队列</span></span><br><span class="line">  <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 队列是否为空</span></span><br><span class="line">  <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.length === <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回队列的元素个数</span></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.length;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在控制台打印出队列的字符串形式</span></span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(items.toString());</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>优先队列<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PriorityQueue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> items = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> QueueElement = <span class="function"><span class="keyword">function</span>(<span class="params">element, priority</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">    <span class="keyword">this</span>.priority = priority;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span>(<span class="params">element, priority</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> queueElement = <span class="keyword">new</span> QueueElement(element, priority);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      items.push(queueElement);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> added = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">        <span class="comment">// priority越小，优先级越大，优先级相同时按入队先后排序</span></span><br><span class="line">        <span class="keyword">if</span> (items[i].priority &gt; queueElement.priority) &#123;</span><br><span class="line">          items.splice(i, <span class="number">0</span>, queueElement);</span><br><span class="line">          added = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!added) &#123;</span><br><span class="line">        items.push(queueElement);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在控制台打印出队列的字符串形式</span></span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(items[i].element + <span class="string">' -- '</span> + items[i].priority);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他方法和Queue一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="击鼓传花游戏模拟"><a href="#击鼓传花游戏模拟" class="headerlink" title="击鼓传花游戏模拟"></a>击鼓传花游戏模拟</h3><p>1、概念: 在游戏中，孩子们围成一个圆圈，将花尽快的传递给旁边的人，某一时刻传花停止，花在谁的手中谁被淘汰，直至剩下最后一个孩子为胜利者</p>
<p>2、原理: 利用循环队列</p>
<p>3、代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hotPotato = <span class="function"><span class="keyword">function</span>(<span class="params">nameList, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nameList.length; i++) &#123;</span><br><span class="line">    queue.enqueue(nameList[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> eliminated = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">      queue.enqueue(queue.dequeue());</span><br><span class="line">    &#125;</span><br><span class="line">    eliminated = queue.dequeue();</span><br><span class="line">    <span class="built_in">console</span>.log(eliminated + <span class="string">'在击鼓传花游戏中被淘汰'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> queue.dequeue();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 《学习JavaScript数据结构与算法》 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《学习JavaScript数据结构与算法》读书笔记--栈]]></title>
      <url>/2017/03/28/%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E6%A0%88/</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>栈是一种遵循<strong>后进先出</strong>(LIFO)的有序集合。新添加的或待删除的元素保存在栈的末尾，称为栈顶，另一端称作栈底。在栈中，新元素都靠近栈顶，旧元素靠近栈底</p>
<p>我把栈想象成一个<strong>装可比克的圆柱桶</strong>，下面是栈底，上面是栈顶。</p>
<h2 id="简单代码实现"><a href="#简单代码实现" class="headerlink" title="简单代码实现"></a>简单代码实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> items = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个元素到栈顶</span></span><br><span class="line">    <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">        items.push(element);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除栈顶的元素并返回</span></span><br><span class="line">    <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.pop();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回栈顶的元素，不对栈进行修改</span></span><br><span class="line">    <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[items.length<span class="number">-1</span>];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈是否为空</span></span><br><span class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length == <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回栈的元素个数</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空栈</span></span><br><span class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        items = [];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印栈</span></span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(items.toString());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回栈的字符串表示</span></span><br><span class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.toString();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="进制转换器-十进制转换成其他进制"><a href="#进制转换器-十进制转换成其他进制" class="headerlink" title="进制转换器(十进制转换成其他进制)"></a>进制转换器(十进制转换成其他进制)</h3><p>1、概念:</p>
<ul>
<li>基数: n进制，n为基数</li>
<li>位权: 对于多位数，处在某一位上的1所表示的数值的大小，称为该位的位权</li>
</ul>
<p>2、原理: 将十进制数与要转换的进制基数相除，直至商为0，将余数从后向前排列即得到转换后的进制数</p>
<p>3、代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base: 基数; decNumber: 十进制数; rem: 余数</span></span><br><span class="line"><span class="keyword">var</span> baseConverter = <span class="function"><span class="keyword">function</span>(<span class="params">decNumber, base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> remStack = <span class="keyword">new</span> Stack(),</span><br><span class="line">      rem,</span><br><span class="line">      baseString = <span class="string">''</span>,</span><br><span class="line">      digits = <span class="string">'0123456789ABCDEF'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (decNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem = <span class="built_in">Math</span>.floor(decNumber % base);</span><br><span class="line">    remStack.push(rem);</span><br><span class="line">    decNumber = <span class="built_in">Math</span>.floor(decNumber / base);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!remStack.isEmpty()) &#123;</span><br><span class="line">    baseString += digits[remStack.pop()];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> baseString;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="平衡圆括号问题"><a href="#平衡圆括号问题" class="headerlink" title="平衡圆括号问题"></a>平衡圆括号问题</h3><p>1、概念: {(()())}是平衡的，([]{}()})是不平衡的</p>
<p>2、原理: 从左向右查找时，第一个遇到的右括号，一定与它左侧最近的左括号匹配。同样，最后一个右括号，一定与第一个左括号相匹配。很像入栈出栈操作</p>
<p>3、代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> match = <span class="function"><span class="keyword">function</span>(<span class="params">open, close</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> opens = <span class="string">'([&#123;'</span>,</span><br><span class="line">      closes = <span class="string">')]&#125;'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> opens.indexOf(open) === closes.indexOf(close);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parenthesesChecker = <span class="function"><span class="keyword">function</span>(<span class="params">symbols</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack(),</span><br><span class="line">      balanced = <span class="literal">true</span>,</span><br><span class="line">      index = <span class="number">0</span>,</span><br><span class="line">      len = symbols.length,</span><br><span class="line">      symbol, top;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; len &amp;&amp; balanced) &#123;</span><br><span class="line">    symbol = symbols[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (symbol === <span class="string">'('</span> || symbol === <span class="string">'['</span> || symbol === <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">      stack.push(symbol);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        balanced = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        top = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (!match(top, symbol)) &#123;</span><br><span class="line">          balanced = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (balanced &amp;&amp; stack.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h3><p>1、概念: 从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数</p>
<p>2、原理: 运用递归，可以将步骤抽象为：</p>
<ul>
<li>(1): 先将A柱的n-1个移动到B柱</li>
<li>(2): 再将A柱的最后一个移动到C柱</li>
<li>(3): 最后再将B柱的n-1个移动到C柱</li>
</ul>
<p>3、代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">                        <span class="comment">// 将from塔的前n个盘子移动到to塔上</span></span><br><span class="line"><span class="keyword">var</span> towerOfHanoi = <span class="function"><span class="keyword">function</span>(<span class="params">n, from, to, helper</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    towerOfHanoi(n<span class="number">-1</span>, <span class="keyword">from</span>, helper, to);</span><br><span class="line">    <span class="comment">// 记录步数并输出当前操作</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第'</span> + count + <span class="string">'步: '</span> + <span class="keyword">from</span>.peek() + <span class="string">'号盘子: '</span> + <span class="keyword">from</span>.name + <span class="string">'----&gt;'</span> + to.name);</span><br><span class="line">    to.push(<span class="keyword">from</span>.pop());</span><br><span class="line">    towerOfHanoi(n<span class="number">-1</span>, helper, to, <span class="keyword">from</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> Stack(),</span><br><span class="line">    dest = <span class="keyword">new</span> Stack(),</span><br><span class="line">    helper = <span class="keyword">new</span> Stack();</span><br><span class="line"></span><br><span class="line">source.name = <span class="string">'A'</span>;</span><br><span class="line">dest.name = <span class="string">'C'</span>;</span><br><span class="line">helper.name = <span class="string">'B'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = num; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">  source.push(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">towerOfHanoi(num, source, dest, helper);</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 《学习JavaScript数据结构与算法》 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript操作DOM常用API总结]]></title>
      <url>/2017/03/28/JavaScript%E6%93%8D%E4%BD%9CDOM%E5%B8%B8%E7%94%A8API%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>原文地址:<a href="http://www.imooc.com/article/2562" target="_blank" rel="external">http://www.imooc.com/article/2562</a></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1、Node类型:</p>
<ul>
<li>JS中所有节点都继承自Node类型，都共享着相同的基本属性和方法</li>
<li>Node有一个属性<code>nodeType</code>表示Node的类型，是一个整数</li>
<li>我们最常用的就是<code>element</code>、<code>text</code>、<code>attribute</code>、<code>comment</code>、<code>document</code>、<code>document_fragment</code></li>
</ul>
<p>2、<code>HTMLCollection</code>和<code>NodeList</code>的区别:</p>
<ul>
<li><code>HTMLCollection</code>是元素集合，<code>NodeList</code>是节点集合(即可以包含元素，也可以包含文本节点)</li>
<li>相同点:<ul>
<li>都是类数组对象，有length属性</li>
<li>都是只读的</li>
<li>都是实时的，有个例外就是<code>querySelectorAll</code>返回的NodeList不是实时的</li>
<li>都有item()方法，通过index或id获取元素</li>
<li>都可以通过属性的方式访问元素</li>
</ul>
</li>
<li>不同点:<ul>
<li><code>HTMLCollection</code>对象有namedItem()方法，可以传递id或name来获取元素</li>
<li><code>HTMLCollection</code>的item方法还有通过属性获取元素可以支持id和name，而<code>NodeList</code>只支持id</li>
</ul>
</li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="节点创建型API"><a href="#节点创建型API" class="headerlink" title="节点创建型API"></a>节点创建型API</h3><p>1、<code>document.createElement(tagName)</code><br>2、<code>document.createTextNode(text)</code><br>3、<code>node.cloneNode(bool)</code>: 接收一个boll参数，表示是否复制子元素</p>
<ul>
<li>bool值最好传入</li>
<li>通过<code>addEventListener</code>或<code>onclick</code>进行绑定，克隆副本不会绑定该事件，如果是内联绑定克隆节点会绑定该事件<br>4、<code>document.createDocumentFragment()</code>: 创建一个<code>documentFragment</code>，作用主要用于储存临时的节点准备添加到文档中</li>
</ul>
<p>总结:</p>
<ul>
<li>创建的节点是孤立的，要通过appendChild等方法添加到文档中</li>
<li>cloneNode要注意被复制的节点是否包含子节点和事件绑定问题</li>
<li>createDocumentFragment用来解决添加大量节点时的性能问题</li>
</ul>
<h3 id="页面修改型API"><a href="#页面修改型API" class="headerlink" title="页面修改型API"></a>页面修改型API</h3><p>1、<code>parent.appendChild(child)</code>:</p>
<ul>
<li>添加节点会作为父节点的最后一个子节点</li>
<li>如果被添加的节点在页面中存在，则执行后这个节点会添加到指定位置，原本位置会移除该节点</li>
</ul>
<p>2、<code>parent.insertBefore(newNode, child)</code>: 如果第二个参数为<code>undefined</code>或<code>null</code>则会添加到末尾<br>3、<code>parent.removeChild(node)</code><br>4、<code>parent.replaceChild(newChild, oldChild)</code></p>
<h3 id="节点查询型API"><a href="#节点查询型API" class="headerlink" title="节点查询型API"></a>节点查询型API</h3><p>1、<code>document.getElementById(id)</code>: 只查找存在于文档中的元素，如果有多个元素id相同，返回第一个<br>2、<code>document.getElementsByTagName(tagName)</code>:</p>
<ul>
<li>返回一个即时的HTMLCollection类型,即该集合内部的元素会随着你添加删除等操作随时变化</li>
<li>如果没有找到，返回一个空的HTMLCollection</li>
<li><code>*</code>表示所有标签</li>
</ul>
<p>3、<code>document.getElementsByName</code>:</p>
<ul>
<li>返回一个即时的Nodelist对象，随时变化</li>
<li>html中并不是所有元素都有name属性，比如div，但如果设置也是可以被查到的</li>
<li>在IE中，如果id设置成某个值，传入该函数的参数与id值相同，也可以被找到</li>
</ul>
<p>4、<code>document.getElementsByClassName(classNames)</code>:</p>
<ul>
<li>返回一个即时的HTMLCollection</li>
<li>如果获取两个以上的classname，可以传入多个，用空格分隔</li>
</ul>
<p>5、<code>document.querySelector</code>:</p>
<ul>
<li>通过css选择器查找元素，返回第一个匹配的元素，没有匹配返回null。</li>
<li>算法使用的是<strong>深度优先搜索</strong>来获取元素</li>
</ul>
<p>6、<code>document.querySelector</code>:</p>
<ul>
<li>和上面方法一样，不同的是返回所有匹配的元素，可以匹配多个选择符</li>
<li>搜索方式也是深度优先搜索。</li>
<li>返回的是非即时的NodeList</li>
</ul>
<h3 id="节点关系型API"><a href="#节点关系型API" class="headerlink" title="节点关系型API"></a>节点关系型API</h3><p>1、父关系型:</p>
<ul>
<li>parentNode: 表示元素的父节点</li>
<li>parentElement: 返回元素的父元素节点，父节点如果不是element，返回null</li>
</ul>
<p>2、兄弟关系型:</p>
<ul>
<li>previousSibling: 节点的前一个节点<ul>
<li>如果该节点是第一个节点，返回null</li>
<li>注意有可能拿到的是文本节点或注释节点，要进行处理</li>
</ul>
</li>
<li>previousElementSibling: 返回前一个<strong>元素</strong>节点</li>
<li>nextSibling: 节点的后一个节点<ul>
<li>如果该节点是最后一个节点，返回null</li>
<li>注意有可能拿到的是文本节点或注释节点，要进行处理</li>
</ul>
</li>
<li>nextElementSibling: 返回一个元素节点</li>
</ul>
<p>3、子关系型:</p>
<ul>
<li>childNodes: 返回一个即时的NodeList，表示子元素的子节点列表</li>
<li>children: 一个即时的HTMLCollection，子节点都是element</li>
<li>firstNode: 第一个子节点</li>
<li>lastNode: 最后一个子节点</li>
<li>hasChildNodes: 判断是否包含子节点</li>
</ul>
<p>4、元素属性型:</p>
<ul>
<li>element.setAttribute(name, value): 根据名称和值修改元素的特性</li>
<li>element.getAttribute(name): 返回特性名相应的值，没有返回null或空字符串</li>
</ul>
<p>5、元素样式型:</p>
<ul>
<li>window.getComputedStyle(element, pseudoElt):<ul>
<li>获得元素计算后的样式</li>
<li>返回一个CSSStyleDecaration对象</li>
</ul>
</li>
<li>element.getBoundingClientRect():<ul>
<li>clientRect是一个DOMRect对象，包含<code>left</code>、<code>top</code>、<code>bottom</code>、<code>right</code>，是相对于可视窗口的距离，滚动距离发生改变时，他们的值会发生改变</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> DOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《学习JavaScript数据结构与算法》读书笔记--数组]]></title>
      <url>/2017/03/25/%E3%80%8A%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p><code>array1.concat(array2, array3, ...)</code>:</p>
<ul>
<li>作用: 用于连接两个或多个数组。</li>
<li>参数: 多个数组</li>
<li>返回值: 连接后的新数组</li>
<li>注意: <strong>不会改变现有的数组</strong></li>
</ul>
<h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p><code>array.every(function(currentValue, index, arr), thisValue)</code>:</p>
<ul>
<li>作用: 检测数组中所有元素是否都符合指定条件</li>
<li>参数: 函数、 <code>thisValue</code>: 传入的<code>this</code>值，可选</li>
<li>返回值: true OR false</li>
<li>注意:<ul>
<li>检测到不满足条件的元素时，返回false，且剩余元素不再执行检测</li>
<li>不对空数组进行检测</li>
<li>不改变原数组</li>
</ul>
</li>
</ul>
<h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p><code>array.some(function(currentValue, index, arr), thisValue)</code>:</p>
<ul>
<li>作用: 检测数组中是否有元素符合条件，有一个满足则返回true</li>
<li>参数: 函数</li>
<li>返回值: true OR false</li>
<li>注意: 不会对空数组进行检测， 不会改变原数组</li>
</ul>
<h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><p><code>array.fill(value, start, end)</code>:</p>
<ul>
<li>作用: 用于将一个固定值替换数组中的元素</li>
<li>参数:<ul>
<li>value: <strong>必需</strong>， 填充的值</li>
<li>start: <strong>可选</strong>，开始填充位置(包括)</li>
<li>end: <strong>可选</strong>， 停止填充位置(不包括)，默认为<code>array.length</code></li>
</ul>
</li>
<li>返回值: 填充后的数组</li>
<li>注意: 改变原数组</li>
</ul>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>array.filter(function(currentValue, index, arr), thisValue)</code>:</p>
<ul>
<li>作用: 返回符合过滤条件的数组元素</li>
<li>参数: 函数、<code>thisValue</code>: 传入的<code>this</code>值，可选</li>
<li>返回值: 由符合条件元素组成的新数组</li>
<li>注意:<ul>
<li>不会对空数组进行检测</li>
<li>不会改变原有数组</li>
</ul>
</li>
</ul>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p><code>array.find(function(currentValue, index, arr), thisValue)</code>:</p>
<ul>
<li>作用: 返回符合传入函数条件的数组第一个元素</li>
<li>参数: 函数、<code>thisValue</code>: 传入的<code>this</code>值，可选</li>
<li>返回值: 符合条件的数组元素，没有符合条件返回-1</li>
<li>注意:<ul>
<li>不会对空数组进行检测</li>
<li>不会改变原数组</li>
</ul>
</li>
</ul>
<h2 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h2><p><code>array.findIndex(function(currentValue, index, arr), thisValue)</code>: 作用和<code>find()</code>相同，只不过返回的是元素的索引值</p>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p><code>array.forEach(function(currentValue, index, arr), thisValue)</code>:</p>
<ul>
<li>作用: 对数组每个元素执行某项操作</li>
<li>参数: 函数</li>
<li>返回值: <code>undefined</code></li>
<li>注意:<ul>
<li>不改变原数组</li>
<li>空数组不执行</li>
</ul>
</li>
</ul>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>array.map(function(currentValue, index, arr), thisValue)</code>:</p>
<ul>
<li>作用: 对数组每个元素执行某种操作，将处理后的值以新数组的形式返回</li>
<li>参数: 函数</li>
<li>返回值: 新数组，数组中的元素为原始数组元素调用函数处理后返回的值</li>
<li>注意:<ul>
<li>按照原始数组元素顺序依次处理元素</li>
<li>不会对空数组进行执行</li>
<li>不改变原数组</li>
</ul>
</li>
</ul>
<h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p><code>array.indexOf(item, start)</code>:</p>
<ul>
<li>作用: 返回查找字符串在数组首次出现的位置</li>
<li>参数:<ul>
<li>item: 要查找的元素</li>
<li>start: 在数组中开始检索的位置，未指定从0开始</li>
</ul>
</li>
<li>返回值: 元素在数组中的位置，未找到返回-1</li>
</ul>
<h2 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h2><p><code>array.lastIndexOf(item, start)</code>: 作用和<code>indexOf()</code>相同，不过返回的是元素最后一次出现的位置，start则是从该位置向前查找</p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p><code>array.join(separator)</code>:</p>
<ul>
<li>作用: 把数组中的所有元素转换为一个字符串</li>
<li>参数: 可选，指定要选择的分隔符，如省略以逗号作为分隔符</li>
<li>返回值: 生成的字符串</li>
</ul>
<h2 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h2><p><code>array.shift()</code>:</p>
<ul>
<li>作用: 删除数组第一个元素并返回该元素</li>
<li>参数: 无</li>
<li>返回值: 被删除的元素</li>
<li>注意: 改变原数组</li>
</ul>
<h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><p><code>array.pop()</code>:</p>
<ul>
<li>作用: 删除数组最后一个元素并返回</li>
<li>参数: 无</li>
<li>返回值: 被删除的元素</li>
<li>注意: 改变原数组及其长度</li>
</ul>
<h2 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h2><p><code>array.unshift(item1, item2, ...)</code>:</p>
<ul>
<li>作用: 向数字开头添加一个或多个元素，并返回新的长度</li>
<li>参数: 要添加的元素</li>
<li>返回值: 新数组的长度</li>
<li>注意: 改变原数组</li>
</ul>
<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p><code>array.push(item1, item2, ...)</code>:</p>
<ul>
<li>作用: 向元素末尾添加一个或多个元素，并返回新的长度</li>
<li>参数: 一个或多个元素</li>
<li>返回值: 插入新元素后的数组长度</li>
<li>注意: 改变原数组及其长度</li>
</ul>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p><code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code>:</p>
<ul>
<li>作用: 接收一个函数作为累加器，数组中的每一个值(从左到右)开始缩减，最终计算为一个值</li>
<li>参数:<ul>
<li>total: 必需，初始值或者计算结束的返回值</li>
<li>currentValue: 必需，当前元素</li>
<li>currentIndex: 可选，当前元素的索引</li>
<li>arr: 可选，当前的数组对象</li>
<li>initialValue: 可选，传递给函数的初始值</li>
</ul>
</li>
<li>返回值: 返回计算的结果</li>
<li>注意: 不改变原数组，对空数组不执行</li>
</ul>
<h2 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h2><p><code>arr.reduceRight(function(total, currentValue, currentIndex, arr), initialValue)</code>: 作用和<code>array.reduce()</code>相同，不过累加的方向是从数组末尾开始</p>
<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><p><code>arr.reverse()</code>:</p>
<ul>
<li>作用: 用于颠倒数组中元素的方向</li>
<li>参数: 无</li>
<li>返回值: 颠倒后的数组</li>
<li>注意: 改变原数组</li>
</ul>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p><code>array.slice(start, end)</code>:</p>
<ul>
<li>作用: 从数组中返回选定范围的元素</li>
<li>参数:<ul>
<li>start: 必须，范围的开始位置(包含)，如果是负数从尾部开始算起，-1指最后一个元素</li>
<li>end: 可选，范围的结束位置(不包含)，不指定则截取到数组末尾。如果为负数从尾部算起，-1指最后一个元素</li>
</ul>
</li>
<li>返回值: 指定范围的数组元素</li>
<li>注意: 不改变原有数组</li>
</ul>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p><code>array.splice(index, howmany, item...)</code>:</p>
<ul>
<li>作用: 用于插入删除或替换数组的元素</li>
<li>参数:<ul>
<li>index: 从index处(包含)开始添加/删除元素</li>
<li>howmany: 应该删除多少元素，为0表示不删除元素，未规定则删除从index开始到原数组结尾所有元素</li>
<li>item…: 可选，要添加的元素</li>
</ul>
</li>
<li>返回值: 如果删除了元素，返回的是含有被删除元素的数组。没有删除元素返回空数组</li>
</ul>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p><code>array.sort(sortfunction(a, b))</code>:</p>
<ul>
<li>作用: 对数组的元素进行排序，默认为按字母升序<ul>
<li>如果函数返回值小于0，a会被排到b之前</li>
<li>如果函数返回值等于0，a和b的相对位置不变</li>
<li>如果函数返回值大于0，a会被排到b之后</li>
</ul>
</li>
<li>参数: 排序函数</li>
<li>返回值: 对数组的引用</li>
<li>注意: 数组在原数组上进行排序，不生成副本。即会改变原数组</li>
<li>PS: 为啥我感觉这个传入的函数好难理解.我就理解成返回值小于0，顺序就是形参的位置顺序</li>
</ul>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p><code>array.toString()</code>: 将数组元素转化为字符串，元素间用逗号隔开</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>改变原数组的方法: <code>fill</code>、<code>shift</code>、<code>pop</code>、<code>push</code>、<code>unshift</code>、<code>reverse</code>、<code>splice</code></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 《学习JavaScript数据结构与算法》 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript event对象]]></title>
      <url>/2017/03/23/javascript%20event%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h2 id="clientX几个相似属性"><a href="#clientX几个相似属性" class="headerlink" title="clientX几个相似属性"></a>clientX几个相似属性</h2><p>1、<code>event.clientX</code>、<code>event.clientY</code>:<br>鼠标相对于浏览器窗口可视区域的X，Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。IE事件和标准事件都定义了这2个属性<br>2、<code>event.pageX</code>、<code>event.pageY</code>:<br>类似于event.clientX、event.clientY，但它们使用的是文档坐标而非窗口坐标。这2个属性不是标准属性，但得到了广泛支持。IE事件中没有这2个属性。<br>3、<code>event.offsetX</code>、<code>event.offsetY</code>:<br>鼠标相对于事件源元素（srcElement）的X,Y坐标，只有IE事件有这2个属性，标准事件没有对应的属性。<br>4、<code>event.screenX</code>、<code>event.screenY</code>:<br>鼠标相对于用户显示器屏幕左上角的X,Y坐标。标准事件和IE事件都定义了这2个属性</p>
<p><strong>图示</strong>:<br><img src="/2017/03/23/javascript event对象/clientX.png" alt="图片来源红黑联盟"></p>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IFE </tag>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IFE糯米学院--有趣的鼠标悬浮模糊效果的实现]]></title>
      <url>/2017/03/22/IFE%E7%B3%AF%E7%B1%B3%E5%AD%A6%E9%99%A2--%E6%9C%89%E8%B6%A3%E7%9A%84%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AE%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h2 id="需要实现的功能"><a href="#需要实现的功能" class="headerlink" title="需要实现的功能"></a>需要实现的功能</h2><p>1、鼠标悬浮时背景图片产生模糊效果<br>2、实现文字的流光渐变效果<br>3、按钮边框从中间到两边扩展开</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>1、利用CSS3的filter属性，blur()实现<br>2、把文字看成纸上的镂空，背景是丰富的颜色，背景在动，就会实现这种效果。为此需要一下几个CSS属性：</p>
<ul>
<li><code>background: linear-gradient(direction, color-stop1, color-stop2, ...)</code>: 实现背景的颜色渐变</li>
<li><code>color: transparent</code>: 文字颜色透明，可以看到背景</li>
<li><code>background-clip: text</code>: 裁剪背景只在文字区域显示</li>
<li><code>background-size: 200% 100%</code>: 背景区域变宽，通过<code>background-position</code>移动背景</li>
</ul>
<p>3、我添加了两个div，分别设置了上下和左右边框，然后以中心为轴旋转90deg，这样就看不到了。鼠标悬浮的时候再旋转回来，视觉效果上就是边框从中心向两边伸展开来<br>4、细节上采用了<code>transition</code>来保证鼠标移入和移出时的过渡动画。最开始都采用的<code>animation</code>实现动画，但发现鼠标移出的时候消失的很生硬，就切换成了<code>transtion</code>来实现过渡</p>
<h2 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- 图片模糊效果 -- */</span></span><br><span class="line"><span class="selector-id">#image</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-filter</span>: <span class="built_in">blur</span>(4px);</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(4px);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- 文字的流光渐变 -- */</span></span><br><span class="line"><span class="selector-id">#text</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: transparent;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(left, #147B96, #E6D205 25%, #147B96 50%, #E6D205 75%, #147B96);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(left, #147B96, #E6D205 25%, #147B96 50%, #E6D205 75%, #147B96);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(left, #147B96, #E6D205 25%, #147B96 50%, #E6D205 75%, #147B96);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(left, #147B96, #E6D205 25%, #147B96 50%, #E6D205 75%, #147B96);</span><br><span class="line">  <span class="attribute">-webkit-background-clip</span>: text;</span><br><span class="line">  <span class="attribute">-ms-background-clip</span>: text;</span><br><span class="line">  <span class="attribute">-moz-background-clip</span>: text;</span><br><span class="line">  <span class="attribute">background-clip</span>: text;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">200%</span> <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">animation</span>: textGradual <span class="number">2s</span> infinite linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> textGradual &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;<span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>&#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;<span class="attribute">background-position</span>: -<span class="number">100%</span> <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码和SHOW"><a href="#完整代码和SHOW" class="headerlink" title="完整代码和SHOW"></a>完整代码和SHOW</h2><p><a href="https://github.com/codeArvin/IFE/tree/master/nuomi/task1" target="_blank" rel="external">完整代码</a>有点乱<br><a href="https://codearvin.github.io/IFE/nuomi/task1/index.html">SHOW</a></p>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IFE </tag>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[transition transform animation]]></title>
      <url>/2017/03/22/transition%20transform%20animation/</url>
      <content type="html"><![CDATA[<h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><p>CSS3的过渡属性，从某一种样式转变到另一种样式时候会产生过渡效果<br>1、<code>transition</code>: <code>property duration timing-function delay</code></p>
<ul>
<li><code>property</code>: 需要过渡的CSS属性。多个属性用<code>,</code>隔开</li>
<li><code>duration</code>: 过渡时间，单位ms，默认0</li>
<li><code>timing-function</code>: 效果的转速曲线。默认ease<ul>
<li><code>linear</code>: 相同速度</li>
<li><code>ease</code>: 慢-快-慢</li>
<li><code>ease-in</code>: 慢-正常</li>
<li><code>ease-out</code>: 正常-慢</li>
<li><code>ease-in-out</code>: 慢-正常-慢</li>
</ul>
</li>
<li><code>delay</code>: 延迟多久开始动画，单位ms，默认0</li>
</ul>
<h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><p>CSS3的动画属性，可以设置样式的连续变化<br>通过<code>@keyframes</code>设置动画，<code>animation</code>设置动画属性<br>1、<code>@keyframes</code>: <code>animationname {keyframes-selector {css-styles;}}</code><br>示例:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- 如果只有两个变化可以用from to 来代替0% 100% --*/</span></span><br><span class="line"><span class="comment">/* -- 多个属性用`;`隔开 -- */</span></span><br><span class="line">@<span class="keyword">keyframes</span> mymove</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">top</span>:<span class="number">100px</span>;&#125;</span><br><span class="line">75%  &#123;<span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">100% &#123;<span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、<code>animation</code>: <code>name duration timing-function delay iteratin-count direction fill-mode</code><br><code>play-state</code></p>
<ul>
<li><code>name</code>: 就是<code>@keyframes</code>设置的名字</li>
<li><code>duration</code>: 动画完成时间</li>
<li><code>timing-function</code>: 动画效果的转速曲线，值和<code>transition</code>的相同</li>
<li><code>delay</code>: 延迟时间</li>
<li><code>iteration-count</code>: 动画播放的次数</li>
<li><code>direction</code>: 是否循环交替反向播放<ul>
<li><code>normal</code>: 默认值，正常播放</li>
<li><code>reverse</code>: 反向播放</li>
<li><code>alternate</code>: 奇次正向，偶次反向</li>
<li><code>alternate</code>: 奇次反向，偶次正向</li>
</ul>
</li>
<li><code>fill-mode</code>: 动画不播放时的应用样式</li>
<li><code>play-state</code>: 指定动画的暂停与播放<ul>
<li><code>paused</code>: 暂停</li>
<li><code>running</code>: 播放</li>
</ul>
</li>
</ul>
<h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>CSS3的2D、3D转换属性，指定元素的移动翻转拉伸等<br><strong>2D</strong>:<br>1、<code>translate(x,y)</code>: 感觉像relative。左上角a,右上角b,左下角c。a为坐标原地，a-&gt;b为x轴,a-&gt;c为y轴，通过传入x,y值指定位置<br>2、<code>rotate(deg)</code>: 绕元素中心旋转，传入一个角度<br>3、<code>scale(x,y)</code>: 宽变为原来的x倍，高变为原来的y倍<br>4、<code>skew(x,y)</code>: 指定X轴Y轴的倾斜角度<br>5、<code>matrix()</code>: 将2D变换方法合并成一个<br><strong>3D</strong>:<br>1、<code>rotateX(deg)</code>: 以X轴旋转<br>2、<code>rotateY(deg)</code>: 以Y轴旋转</p>
<p><strong>先写这么多，后续再完善</strong></p>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p><code>background</code>: <code>linear-gradient(direction, color-stop1, color-stop2, ...)</code><br><code>direction</code>: 渐变的方向，可以取以下这几种值: <code>left</code>、<code>left top</code>、<code>0deg</code>、<code>90deg</code></p>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IFE </tag>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对DOM中offsetWidth等几个属性的理解]]></title>
      <url>/2017/03/21/%E5%AF%B9DOM%E4%B8%ADoffsetWidth%E7%AD%89%E5%87%A0%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="属性概念"><a href="#属性概念" class="headerlink" title="属性概念"></a>属性概念</h2><p><strong>这几个概念是在网上不同的文章，文档中找的</strong><br>1、<code>offsetWidth</code>: 对象整体的实际宽度，包滚动条等边线，会随对象显示大小的变化而改变。<br>2、<code>offsetHeight</code>: 对象整体的实际高度，包滚动条等边线，会随对象显示大小的变化而改变。<br>3、<code>offsetLeft</code>: 元素的左外边框至offsetParent元素的左内边框之间的像素距离<br>4、<code>offsetTop</code>:　元素的上外边框至offsetParent元素的上内边框之间的像素距离<br>5、<code>offsetParent</code>: 与当前元素最近的经过定位(position不等于static)的父级元素</p>
<p>7、<code>scrollWidth</code>: 对象的实际内容的宽度，不包边线宽度，会随对象中内容超过可视区后而变大。<br>8、<code>scrollHeight</code>: 对象的实际内容的高度，不包边线宽度，会随对象中内容超过可视区后而变大。<br>9、<code>scrollLeft</code>: 页面利用滚动条滚动到右侧时，隐藏在滚动条左侧的页面的宽度<br>10、<code>scrollTop</code>: 页面利用滚动条滚动到下方时，隐藏在滚动条上方的页面的高度</p>
<p>11、<code>clientWidth</code>: 对象内容的可视区的宽度，不包滚动条等边线，会随对象显示大小的变化而改变。<br>12、<code>clientHeight</code>: 对象内容的可视区的高度，不包滚动条等边线，会随对象显示大小的变化而改变。<br>13、<code>clientLeft</code>: 表示一个元素的左边框的宽度，以像素表示。如果元素的文本方向是从右向左（RTL, right-to-left），并且由于内容溢出导致左边出现了一个垂直滚动条，则该属性包括滚动条的宽度。clientLeft 不包括左外边距和左内边距。<br>14、<code>clientTop</code>: 一个元素顶部边框的宽度（以像素表示）。不包括顶部外边距或内边距。</p>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>把这几个属性，分成三部分，结合下面三个图片理解会更好，网上有人说第三个图片不完全正确，我们要辩证的看。<br><strong><code>body</code>和其他元素一样，第三个图片中<code>body</code>充满整个浏览器，这是需要设置的，不然<code>body</code>会像其他元素一样，并不会充满屏幕</strong>(<em>update at 2017/10/27 20:47:00</em>)<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这几个属性可分成三类：offset、client、scroll。把一个网页元素的显示看成是一个相框，中间是玻璃，我们可以看到玻璃后面的内容，相册有边框。而内容则是在玻璃后面的纸，我们可以透过玻璃看到后面纸的内容，纸是可以随意移动的。而对应到这三类就是玻璃区域对应client、整个相框(包括玻璃和边框)对应offset、纸张对应scroll。<br>这样我们就可以对这几个属性进行理解了。</p>
<ul>
<li><code>clientWidth</code>: 玻璃的宽度</li>
<li><code>clientHeight</code>: 玻璃的高度</li>
<li><code>clientTop</code>: 玻璃上边缘与相框上边缘的距离，即相框边框的宽度，如果中间有其他的什么东西增加了距离也要算进去</li>
<li><code>clientLeft</code>: 玻璃左边缘和相框左边缘的距离</li>
</ul>
<ul>
<li><code>offsetWidth</code>: 相框的宽度</li>
<li><code>offsetHeight</code>: 相框的高度</li>
<li><code>offsetParent</code>: 相框外面的相框</li>
<li><code>offsetTop</code>: 相框上边缘与外面相框的玻璃上边缘的距离</li>
<li><code>offsetLeft</code>: 相册左左边缘与外面相框的玻璃左边缘的距离</li>
</ul>
<ul>
<li><code>scrollWidth</code>: 纸张的宽度</li>
<li><code>scrollHeight</code>: 纸张的高度</li>
<li><code>scrollTop</code>: 纸张的上边缘与玻璃的上边缘的距离</li>
<li><code>scrollLeft</code>: 纸张的左边缘与玻璃的左边缘的距离</li>
</ul>
<p><strong>上面几个抽象后的概念要结合着第三幅图片理解，会发现这几个概念其实挺好理解的</strong></p>
<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="/2017/03/21/对DOM中offsetWidth等几个属性的理解/1.png" alt=""><br><img src="/2017/03/21/对DOM中offsetWidth等几个属性的理解/2.png" alt=""><br><img src="/2017/03/21/对DOM中offsetWidth等几个属性的理解/3.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> DOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端学习--事件冒泡]]></title>
      <url>/2017/03/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0--%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1、浏览器对事件的处理方式有三种，事件冒泡只是其中一种</p>
<ul>
<li>IE从里到外（inside→outside）的冒泡型事件。</li>
<li>Netscape4.0从外到里（outside→inside）的捕获型事件。</li>
<li>DOM事件流，先从外到里，再从里到外回到原点（outside→inside→outside）的事件捕获方法</li>
</ul>
<p>2、不是所有事件都能冒泡，这几个事件不可以: blur、focus、load、unload。</p>
<p>3、不同浏览器事件处理方式细节不同</p>
<h2 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopBubble</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e &amp;&amp; e.stopPropagation) &#123;</span><br><span class="line">    e.stopPropagation(); <span class="comment">// W3C</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>; <span class="comment">// IE</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h2><p>支持W3C标准的浏览器的<code>addEventListener(event, fn, useCapture)</code>，第三个参数是Boolean值，<code>true</code>为事件捕获，<code>false</code>为事件冒泡。默认为<code>false</code>,即事件冒泡</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>阻止浏览器的默认行为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.preventDefault(); <span class="comment">// W3C</span></span><br><span class="line"><span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>; <span class="comment">// IE</span></span><br></pre></td></tr></table></figure></p>
<p><code>event.stopImmediatePropagation()</code>:<br>如果某个元素有多个相同类型事件的事件监听函数,则当该类型的事件触发时,多个事件监听函数将按照顺序依次执行.如果某个监听函数执行了 event.stopImmediatePropagation()方法,则除了该事件的冒泡行为被阻止之外(event.stopPropagation方法的作用),该元素绑定的后序相同类型事件的监听函数的执行也将被阻止.</p>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> DOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[可复用插件的编写]]></title>
      <url>/2017/03/21/%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E7%BC%96%E5%86%99/</url>
      <content type="html"><![CDATA[<h2 id="drag"><a href="#drag" class="headerlink" title="drag"></a>drag</h2><p><strong>目标</strong>：实现鼠标的拖拽移动功能<br><strong>实现方式</strong>：获取到鼠标在可以拖拽区域按下时鼠标与移动对象左上角的距离信息。拖拽时候鼠标和移动对象是相对静止的，根据这个可以实时改变移动对象的left和top值。就可以达到拖拽移动效果<br><strong>小细节</strong>：<br>  1、需要设置移动对象的<code>position</code>值为<code>absolute</code><br>  2、拖拽过程中有时候会选中移动对象内部的文字，影响拖拽，所以把移动对象设置成不可选中文字<br>  3、<code>onmousemove</code>、<code>onmouseup</code>需要设置在document对象上，这样保证可以快速拖拽<br>  4、我在做drag功能的时候同时也在做scale功能，scale功能也用到了document对象的onmousemove和onmouseup，会产生冲突，所以每次在绑定onmousemove和onmouseup之前都先保存当前的onmousemove和onmouseup功能。拖拽完成后再重新绑定原先的功能<br>  5、在获取当前窗口高度的时候由于document.body获取的不是当前窗口高度产生了bug，应用document.documentElement获取<br><strong>其他</strong>：目前功能写成了函数的形式，引入便可以对元素进行拖拽。但在实际情况中可能会产生各种各样的bug，随着我的学习我会不断完善这个函数的</p>
<h2 id="flostLayer"><a href="#flostLayer" class="headerlink" title="flostLayer"></a>flostLayer</h2><p><strong>目标</strong>：实现一个浮出层<br><strong>实现方式</strong>：写好html结构，css样式。通过js将html完善好并注入到页面中。通过设置<code>display</code>值来控制浮出层的显示与隐藏<br><strong>小细节</strong>：<br>1、通过传入一个预先设定好结构的object来设置浮出层的文字内容和一些基础配置<br>2、可以通过show(),remove()来控制浮出层的显示与隐藏<br>3、通过css的<code>calc()</code>进行居中<br><strong>其他</strong>：可能发生id命名冲突导致bug</p>
<h2 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h2><p><strong>目标</strong>：实现对一个div的拖拽放大缩小功能<br><strong>实现方式</strong>：通过实时计算鼠标与div四边的距离信息来检测鼠标在哪个边界，来确定放大缩小的方式。在边界按下鼠标左键并进行拖拽，实时计算鼠标位置，重新设置div的width、height以及left、top。<br><strong>小细节</strong>：<br>1、通过传入一个object来设定放大缩小范围，四边四角哪几个可以进行拖拽以及边界检测的灵敏度值<br>2、拖拽过程中有时候会选中移动对象内部的文字，影响拖拽，所以把移动对象设置成不可选中文字<br>3、需要设置div的position值为absolute<br>4、保存鼠标按下时候的边界值，这样不会因为拖拽过快离开边界而不会进行放大缩小<br>5、对某些重复使用的功能封装成了函数<br>6、事件绑定在document对象上<br><strong>其他</strong>：会不断完善</p>
<h2 id="代码和展示"><a href="#代码和展示" class="headerlink" title="代码和展示"></a>代码和展示</h2><p>1、drag</p>
<ul>
<li><a href="https://github.com/codeArvin/code/blob/master/plugins/drag/drag.js" target="_blank" rel="external">代码地址</a></li>
<li><a href="https://codearvin.github.io/code/plugins/drag">SHOW</a></li>
</ul>
<p>2、floatLayaer</p>
<ul>
<li><a href="https://github.com/codeArvin/code/blob/master/plugins/floatLayer/floatLayer.js" target="_blank" rel="external">代码地址</a></li>
<li><a href="https://codearvin.github.io/code/plugins/floatLayer">SHOW</a></li>
</ul>
<p>3、scale</p>
<ul>
<li><a href="https://github.com/codeArvin/code/blob/master/plugins/scale/scale.js" target="_blank" rel="external">代码地址</a></li>
<li><a href="https://codearvin.github.io/code/plugins/scale">SHOW</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IFE </tag>
            
            <tag> 前端 </tag>
            
            <tag> demo </tag>
            
            <tag> code </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IFE学习 demo]]></title>
      <url>/2017/03/18/IFE%E5%AD%A6%E4%B9%A0%20demo/</url>
      <content type="html"><![CDATA[<h2 id="小薇学院"><a href="#小薇学院" class="headerlink" title="小薇学院"></a>小薇学院</h2><ol>
<li><a href="https://codearvin.github.io/IFE/xiaowei/task1/OnlyHTML.html">task1 零基础HTML编码</a></li>
<li><a href="https://codearvin.github.io/IFE/xiaowei/task2/HTMLandCSS.html">task2 零基础HTML及CSS编码(一)</a></li>
<li><a href="https://codearvin.github.io/IFE/xiaowei/task3/layout.html">task3 三栏式布局</a></li>
<li><a href="https://codearvin.github.io/IFE/xiaowei/task4/location.html">task4 居中和定位问题</a></li>
<li><a href="https://codearvin.github.io/IFE/xiaowei/task5/HTMLandCSS.html">task5 零基础HTML及CSS编码</a></li>
<li><a href="https://codearvin.github.io/IFE/xiaowei/task6/newspaper.html">task6 通过HTML及CSS模拟报纸排版</a></li>
<li><a href="https://codearvin.github.io/IFE/xiaowei/task7/officialWebsite.html">task7 实现常见的技术产品官网的页面架构及样式布局</a></li>
<li><a href="https://codearvin.github.io/IFE/xiaowei/task8/grid.html">task8 响应式网格(栅格化)布局</a></li>
<li><a href="https://codearvin.github.io/IFE/xiaowei/task10/flex.html">task10 Flexbox布局练习</a></li>
</ol>
<h2 id="斌斌学院"><a href="#斌斌学院" class="headerlink" title="斌斌学院"></a>斌斌学院</h2><ol>
<li><a href="https://codearvin.github.io/IFE/binbin/task1">task1 零基础JavaScript编码(一)</a></li>
<li><a href="https://codearvin.github.io/IFE/binbin/task2/index.html">task2 零基础JavaScript编码(二)</a></li>
<li><a href="https://codearvin.github.io/IFE/binbin/task3/index.html">task3 零基础JavaScript编码(三)</a></li>
<li><a href="https://codearvin.github.io/IFE/binbin/task4/index.html">task4 基础JavaScript练习</a></li>
<li><a href="https://codearvin.github.io/IFE/binbin/task5/index.html">task5 基础JavaScript练习</a></li>
<li><a href="https://codearvin.github.io/IFE/binbin/task6">task6 基础JavaScript练习</a></li>
<li><a href="https://codearvin.github.io/IFE/binbin/task7/tree.html">task7 JavaScript和树(一)</a></li>
<li><a href="https://codearvin.github.io/IFE/binbin/task8/tree.html">task8 JavaScript和树(二)</a></li>
<li><a href="https://codearvin.github.io/IFE/binbin/task9/">task9 JavaScript和树(三)</a></li>
</ol>
<h2 id="耀耀学院"><a href="#耀耀学院" class="headerlink" title="耀耀学院"></a>耀耀学院</h2><ol>
<li><a href="https://codearvin.github.io/IFE/yaoyao/task1">task1 表单(一) 单个表单项的检验</a></li>
<li><a href="https://codearvin.github.io/IFE/yaoyao/task2">task2 表单(二) 多个表单项的动态检验</a></li>
<li><a href="https://codearvin.github.io/IFE/yaoyao/task3">task3 表单(三) 联动</a></li>
<li><a href="https://codearvin.github.io/IFE/yaoyao/task4">task4 听指令的小方块(一)</a></li>
<li><a href="https://codearvin.github.io/IFE/yaoyao/task5">task5 听指令的小方块(二)</a></li>
<li><a href="https://codearvin.github.io/IFE/yaoyao/task6">task6 UI组件之浮出层</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Show </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IFE </tag>
            
            <tag> 前端 </tag>
            
            <tag> demo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[FCC学习 demo]]></title>
      <url>/2017/03/18/FCC%E5%AD%A6%E4%B9%A0%20demo/</url>
      <content type="html"><![CDATA[<h2 id="FE-Page"><a href="#FE-Page" class="headerlink" title="FE-Page"></a>FE-Page</h2><ol>
<li><a href="http://fccwork-mks.herokuapp.com/fe/Tribute-Page" target="_blank" rel="external">Tribute Page</a></li>
<li><a href="http://fccwork-mks.herokuapp.com/fe/webpage" target="_blank" rel="external">Personal Portfolio Webpage</a></li>
<li><a href="http://fccwork-mks.herokuapp.com/fe/danmu" target="_blank" rel="external">Danmu App</a></li>
<li><a href="http://fccwork-mks.herokuapp.com/fe/quote" target="_blank" rel="external">Random Quote Machine</a></li>
<li><a href="http://fccwork-mks.herokuapp.com/fe/localweather" target="_blank" rel="external">Local Weather</a></li>
<li><a href="http://fccwork-mks.herokuapp.com/fe/wikiviewer" target="_blank" rel="external">Wikipedia Viewer</a></li>
<li><a href="http://fccwork-mks.herokuapp.com/fe/twitchviewer" target="_blank" rel="external">Twitch Viewer</a></li>
<li><a href="http://fccwork-mks.herokuapp.com/fe/jscalculator" target="_blank" rel="external">Javascript Calculator</a></li>
<li><a href="https://fccwork-mks.herokuapp.com/html/pomodorotimer.html" target="_blank" rel="external">Pomodoro Clock</a></li>
<li><a href="http://fccwork-mks.herokuapp.com/fe/tictactoe" target="_blank" rel="external">Tic Tac Toe Game</a></li>
<li><a href="http://fccwork-mks.herokuapp.com/fe/simongame" target="_blank" rel="external">Simon Game</a></li>
</ol>
<h2 id="API-Projects"><a href="#API-Projects" class="headerlink" title="API Projects"></a>API Projects</h2><ol>
<li><a href="https://fccwork-mks.herokuapp.com/api/timestamp" target="_blank" rel="external">Timestamp Microservice</a></li>
<li><a href="https://fccwork-mks.herokuapp.com/api/reqhdparser" target="_blank" rel="external">Request Header Parser Microservice</a></li>
<li><a href="https://fccwork-mks.herokuapp.com/api/URLshorter" target="_blank" rel="external">URL Shortener Microservice</a></li>
<li><a href="https://fccwork-mks.herokuapp.com/api/imagesearch" target="_blank" rel="external">Image Search Abstraction Layer</a></li>
<li><a href="https://fccwork-mks.herokuapp.com/api/fileMetadata" target="_blank" rel="external">File Metadata Microservice</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Show </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> demo </tag>
            
            <tag> FCC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IFE学习Tips记录]]></title>
      <url>/2017/03/17/IFE%E5%AD%A6%E4%B9%A0Tips%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="正则相关"><a href="#正则相关" class="headerlink" title="正则相关"></a>正则相关</h2><h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><ul>
<li><code>\d</code>: 数字</li>
<li><code>\D</code>: 非数字</li>
<li><code>\w</code>: 所有的单词字符（字母、数字、下划线）<code>[_a-zA-Z0-9]</code></li>
<li><code>\W</code>: 非单词字符<code>[^a-zA-Z0-9]</code></li>
<li><code>\s</code>: 空白符<code>[ \t\n\r]</code></li>
<li><code>\S</code>: 非空白符</li>
<li><code>\t</code>: 制表符</li>
<li><code>\n</code>: 换行符</li>
<li><code>\t</code>: 回车符</li>
<li><code>\b</code>: 单词边界</li>
<li><code>\B</code>: 非单词边界</li>
<li><code>.</code>: 匹配任意单字符，除了<code>\n</code></li>
<li><code>*</code>: 零次或多次</li>
<li><code>+</code>: 一次或多次</li>
<li><code>?</code>: 零次或一次</li>
<li><code>?</code>:放到()第一个选项前可取消缓存</li>
<li><code>[\u4e00-\u9fa5]</code>匹配中文汉字，<code>[\u0391-\uFFE5]</code>匹配全角字符，包括中文符号和中文汉字</li>
</ul>
<h3 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h3><ul>
<li><code>var patt = new RegExp(pattern, modifiers)</code> OR <code>var patt = /pattern/modifiers</code></li>
<li>modifiers:<ul>
<li><code>i</code>: 执行对大小写不敏感的匹配</li>
<li><code>g</code>: 执行全局匹配</li>
<li><code>m</code>: 执行多行匹配</li>
</ul>
</li>
<li><code>test()</code>: 搜索字符串指定值，根据结果返回真或假</li>
<li><code>exec()</code>: 检索字符串中指定值，返回值是一个数组，例如<code>var regex = /hello/; var str = &#39;helloworld&#39;; var result = regex.exec(str)//[&#39;hello&#39;, index: 0, input: &#39;helloworld&#39;]</code>，没有匹配则返回<code>null</code>。<strong>但这个方法只能返回第一个匹配的值</strong></li>
</ul>
<h3 id="支持正则的String对象方法"><a href="#支持正则的String对象方法" class="headerlink" title="支持正则的String对象方法"></a>支持正则的String对象方法</h3><ul>
<li><code>search()</code>: 用于检索字符串中符合正则的子字符串，返回其起始位置，若找不到则返回-1</li>
<li><code>match()</code>: 检索符合正则的子字符串，返回数组，若正则指定<code>g</code>，则包含多个匹配对象，没有匹配则返回null</li>
<li><code>replace(searchValue, newValue)</code>: 用<code>newValue</code>替换<code>searchValue</code>，返回生成的新字符串</li>
<li><code>split(separator, limit)</code>: 以<code>separator</code>分割数组，<code>limit</code>指定返回数组的最大长度。返回分割后的数组</li>
</ul>
<h3 id="select对象"><a href="#select对象" class="headerlink" title="select对象"></a><code>select</code>对象</h3><ul>
<li><code>select.length</code>: 其下<code>option</code>的个数，设为<code>0</code>可以清空下拉数组</li>
<li><code>select.options</code>: 返回其下拉列表所有选项的一个数组</li>
<li><code>add(option, before)</code>: 添加<code>option</code>或<code>optgroup</code>元素,<code>before</code>则指定添加到哪个元素后面,如果为<code>null</code>则添加到选项数组的末尾</li>
<li><code>remove(index)</code>: 删除下拉列表中的索引值为index的元素</li>
</ul>
<h2 id="DOM相关"><a href="#DOM相关" class="headerlink" title="DOM相关"></a>DOM相关</h2><ol>
<li><a href="http://www.runoob.com/jsref/jsref-tutorial.html" target="_blank" rel="external">菜鸟教程DOM参考手册</a></li>
</ol>
<h2 id="布局相关"><a href="#布局相关" class="headerlink" title="布局相关"></a>布局相关</h2><h3 id="inline-block间空隙的解决方法"><a href="#inline-block间空隙的解决方法" class="headerlink" title="inline-block间空隙的解决方法"></a><code>inline-block</code>间空隙的解决方法</h3><p><code>inline-block</code>间空隙出现的原因是标签与标签之间的空格也会被浏览器解析。有以下几种方法<br>1、将两个标签贴合在一起，即前一个标签的结束标签和后一个标签的开始标签挨着写<br>2、设置负的 <code>margin</code><br>3、将父元素的<code>font-size</code>设为0即可<br>4、不写结束标签</p>
<h2 id="CSS相关"><a href="#CSS相关" class="headerlink" title="CSS相关"></a>CSS相关</h2><p>1、通过<code>element.style.transform</code>获取或设置CSS中的<code>transform</code>属性<br>2、DOM元素原来有方向，<code>rotate</code>之后再<code>translate</code>会适应元素旋转后的方向。<strong>注意</strong>：<strong>这个效果必须先旋转再平移</strong><br>3、<code>transition</code>：用来进行CSS变化的过渡，需要指定对应的CSS属性，用逗号分割不同的属性<br>4、用js获取节点属性</p>
<ul>
<li>通过<code>element.style</code>获取或设置的样式是元素的内联样式而不是css样式。如果样式名含有类似<code>background-color</code>等短杠连接，要写成驼峰写法，如<code>backgroundColor</code></li>
<li>如果想获得一个元素最终展示到页面上的样式值可以通过一下方法<ul>
<li>非ie浏览器: <code>window.getComputedStyle(element, null/伪类)</code>: 第一个参数是节点，第二个参数是null时获取节点本身样式，是伪类(:before, :after etc.)时获取节点伪类样式</li>
<li>ie浏览器: <code>element.currentStyle</code></li>
</ul>
</li>
</ul>
<p>可以写一个通用获取样式的方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> style = element.currentStyle ? element.currentStyle : <span class="built_in">window</span>.getComputedStyle(element, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>5、<code>border-collapse: collapse</code>用来设置边框合并<br>6、自定义checkbox。</p>
<ul>
<li>通过CSS伪元素实现。将input隐藏，通过改变相应label样式达到目的</li>
<li>通过雪碧图。改变<code>background-position</code>属性达到目的</li>
</ul>
<p>7、<code>box-shadow</code>: <code>h-shadow v-shadow blur spread color inset</code></p>
<ul>
<li><code>h-shadow</code>: 必需，水平阴影位置</li>
<li><code>v-shadow</code>: 必需，垂直阴影位置</li>
<li><code>blur</code>: 可选，模糊距离</li>
<li><code>spread</code>: 可选，阴影大小</li>
<li><code>color</code>: 可选，阴影颜色</li>
<li><code>inset</code>: 可选，从外层的阴影(开始时)改变阴影内侧阴影</li>
</ul>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>1、<code>parseInt()</code>: 把一个字符串解析成整数</p>
]]></content>
      
        <categories>
            
            <category> 学习记录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IFE </tag>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
